<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Vincenzo Ciancia" />
  <meta name="dcterms.date" content="2025-05-15" />
  <title>Programming Languages Design Workshop</title>
  <style>
html {
color: #1a1a1a;
background-color: #fdfdfd;
}
body {
margin: 0 auto;
max-width: 36em;
padding-left: 50px;
padding-right: 50px;
padding-top: 50px;
padding-bottom: 50px;
hyphens: auto;
overflow-wrap: break-word;
text-rendering: optimizeLegibility;
font-kerning: normal;
}
@media (max-width: 600px) {
body {
font-size: 0.9em;
padding: 12px;
}
h1 {
font-size: 1.8em;
}
}
@media print {
html {
background-color: white;
}
body {
background-color: transparent;
color: black;
font-size: 12pt;
}
p, h2, h3 {
orphans: 3;
widows: 3;
}
h2, h3, h4 {
page-break-after: avoid;
}
}
p {
margin: 1em 0;
}
a {
color: #1a1a1a;
}
a:visited {
color: #1a1a1a;
}
img {
max-width: 100%;
}
svg {
height: auto;
max-width: 100%;
}
h1, h2, h3, h4, h5, h6 {
margin-top: 1.4em;
}
h5, h6 {
font-size: 1em;
font-style: italic;
}
h6 {
font-weight: normal;
}
ol, ul {
padding-left: 1.7em;
margin-top: 1em;
}
li > ol, li > ul {
margin-top: 0;
}
blockquote {
margin: 1em 0 1em 1.7em;
padding-left: 1em;
border-left: 2px solid #e6e6e6;
color: #606060;
}
code {
font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
font-size: 85%;
margin: 0;
hyphens: manual;
}
pre {
margin: 1em 0;
overflow: auto;
}
pre code {
padding: 0;
overflow: visible;
overflow-wrap: normal;
}
.sourceCode {
background-color: transparent;
overflow: visible;
}
hr {
border: none;
border-top: 1px solid #1a1a1a;
height: 1px;
margin: 1em 0;
}
table {
margin: 1em 0;
border-collapse: collapse;
width: 100%;
overflow-x: auto;
display: block;
font-variant-numeric: lining-nums tabular-nums;
}
table caption {
margin-bottom: 0.75em;
}
tbody {
margin-top: 0.5em;
border-top: 1px solid #1a1a1a;
border-bottom: 1px solid #1a1a1a;
}
th {
border-top: 1px solid #1a1a1a;
padding: 0.25em 0.5em 0.25em 0.5em;
}
td {
padding: 0.125em 0.5em 0.25em 0.5em;
}
header {
margin-bottom: 4em;
text-align: center;
}
#TOC li {
list-style: none;
}
#TOC ul {
padding-left: 1.3em;
}
#TOC > ul {
padding-left: 0;
}
#TOC a:not(:hover) {
text-decoration: none;
}
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}

html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } 
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.at { color: #204a87; } 
code span.bn { color: #0000cf; } 
code span.cf { color: #204a87; font-weight: bold; } 
code span.ch { color: #4e9a06; } 
code span.cn { color: #8f5902; } 
code span.co { color: #8f5902; font-style: italic; } 
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.dt { color: #204a87; } 
code span.dv { color: #0000cf; } 
code span.er { color: #a40000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #0000cf; } 
code span.fu { color: #204a87; font-weight: bold; } 
code span.im { } 
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.kw { color: #204a87; font-weight: bold; } 
code span.op { color: #ce5c00; font-weight: bold; } 
code span.ot { color: #8f5902; } 
code span.pp { color: #8f5902; font-style: italic; } 
code span.sc { color: #ce5c00; font-weight: bold; } 
code span.ss { color: #4e9a06; } 
code span.st { color: #4e9a06; } 
code span.va { color: #000000; } 
code span.vs { color: #4e9a06; } 
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } 
</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Programming Languages Design Workshop</h1>
<p class="author">Vincenzo Ciancia</p>
<p class="date">May 15, 2025</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#chapter-1-introduction-to-programming-language-design" id="toc-chapter-1-introduction-to-programming-language-design">Chapter
1: Introduction to Programming Language Design</a>
<ul>
<li><a href="#section-1-what-is-a-programming-language" id="toc-section-1-what-is-a-programming-language">Section 1: What is a
Programming Language?</a>
<ul>
<li><a href="#key-characteristics-of-programming-languages" id="toc-key-characteristics-of-programming-languages">Key
Characteristics of Programming Languages</a></li>
<li><a href="#programming-languages-vs.-natural-languages" id="toc-programming-languages-vs.-natural-languages">Programming
Languages vs. Natural Languages</a></li>
</ul></li>
<li><a href="#section-2-the-importance-of-programming-language-design" id="toc-section-2-the-importance-of-programming-language-design">Section
2: The Importance of Programming Language Design</a>
<ul>
<li><a href="#programming-languages-shape-how-we-think" id="toc-programming-languages-shape-how-we-think">Programming Languages
Shape How We Think</a></li>
<li><a href="#language-design-affects-software-quality" id="toc-language-design-affects-software-quality">Language Design
Affects Software Quality</a></li>
<li><a href="#the-evolution-of-programming-languages" id="toc-the-evolution-of-programming-languages">The Evolution of
Programming Languages</a></li>
</ul></li>
<li><a href="#section-3-modern-language-design-principles" id="toc-section-3-modern-language-design-principles">Section 3: Modern
Language Design Principles</a>
<ul>
<li><a href="#abstraction" id="toc-abstraction">Abstraction</a></li>
<li><a href="#expressiveness" id="toc-expressiveness">Expressiveness</a></li>
<li><a href="#safety" id="toc-safety">Safety</a></li>
<li><a href="#performance" id="toc-performance">Performance</a></li>
<li><a href="#consistency" id="toc-consistency">Consistency</a></li>
</ul></li>
<li><a href="#section-4-using-python-to-explore-programming-language-concepts" id="toc-section-4-using-python-to-explore-programming-language-concepts">Section
4: Using Python to Explore Programming Language Concepts</a>
<ul>
<li><a href="#pythons-suitability-for-language-implementation" id="toc-pythons-suitability-for-language-implementation">Python’s
Suitability for Language Implementation</a></li>
<li><a href="#python-3.10-features-relevant-to-language-design" id="toc-python-3.10-features-relevant-to-language-design">Python 3.10+
Features Relevant to Language Design</a></li>
</ul></li>
<li><a href="#section-5-implementing-language-features-in-python" id="toc-section-5-implementing-language-features-in-python">Section 5:
Implementing Language Features in Python</a>
<ul>
<li><a href="#representing-syntax-abstract-syntax-trees-asts" id="toc-representing-syntax-abstract-syntax-trees-asts">Representing
Syntax: Abstract Syntax Trees (ASTs)</a></li>
<li><a href="#implementing-an-evaluator" id="toc-implementing-an-evaluator">Implementing an Evaluator</a></li>
<li><a href="#pattern-matching-for-ast-processing" id="toc-pattern-matching-for-ast-processing">Pattern Matching for AST
Processing</a></li>
<li><a href="#simple-type-checking" id="toc-simple-type-checking">Simple
Type Checking</a></li>
</ul></li>
<li><a href="#section-6-course-structure" id="toc-section-6-course-structure">Section 6: Course Structure</a>
<ul>
<li><a href="#course-topics" id="toc-course-topics">Course
Topics</a></li>
<li><a href="#projects-and-exercises" id="toc-projects-and-exercises">Projects and Exercises</a></li>
</ul></li>
<li><a href="#section-7-prerequisites-and-setup" id="toc-section-7-prerequisites-and-setup">Section 7: Prerequisites and
Setup</a>
<ul>
<li><a href="#knowledge-prerequisites" id="toc-knowledge-prerequisites">Knowledge Prerequisites</a></li>
<li><a href="#python-environment-setup" id="toc-python-environment-setup">Python Environment Setup</a></li>
</ul></li>
<li><a href="#section-8-additional-resources" id="toc-section-8-additional-resources">Section 8: Additional
Resources</a>
<ul>
<li><a href="#books-on-programming-language-design" id="toc-books-on-programming-language-design">Books on Programming
Language Design</a></li>
<li><a href="#online-resources" id="toc-online-resources">Online
Resources</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-2-types-and-pattern-matching-in-python" id="toc-chapter-2-types-and-pattern-matching-in-python">Chapter 2: Types
and Pattern Matching in Python</a>
<ul>
<li><a href="#section-1-pythons-type-system" id="toc-section-1-pythons-type-system">Section 1: Python’s Type
System</a>
<ul>
<li><a href="#what-are-type-annotations" id="toc-what-are-type-annotations">What are Type Annotations?</a></li>
<li><a href="#basic-types-in-python" id="toc-basic-types-in-python">Basic Types in Python</a></li>
<li><a href="#generic-types" id="toc-generic-types">Generic
Types</a></li>
<li><a href="#union-types-and-optional-values" id="toc-union-types-and-optional-values">Union Types and Optional
Values</a></li>
<li><a href="#type-aliases" id="toc-type-aliases">Type Aliases</a></li>
<li><a href="#literal-types" id="toc-literal-types">Literal
Types</a></li>
</ul></li>
<li><a href="#section-2-structural-pattern-matching" id="toc-section-2-structural-pattern-matching">Section 2: Structural
Pattern Matching</a>
<ul>
<li><a href="#introduction-to-pattern-matching" id="toc-introduction-to-pattern-matching">Introduction to Pattern
Matching</a></li>
<li><a href="#basic-patterns" id="toc-basic-patterns">Basic
Patterns</a></li>
<li><a href="#sequence-patterns" id="toc-sequence-patterns">Sequence
Patterns</a></li>
<li><a href="#class-patterns-and-attribute-matching" id="toc-class-patterns-and-attribute-matching">Class Patterns and
Attribute Matching</a></li>
<li><a href="#complex-pattern-matching-examples" id="toc-complex-pattern-matching-examples">Complex Pattern Matching
Examples</a></li>
</ul></li>
<li><a href="#section-3-combining-types-and-pattern-matching" id="toc-section-3-combining-types-and-pattern-matching">Section 3:
Combining Types and Pattern Matching</a>
<ul>
<li><a href="#algebraic-data-types-in-python" id="toc-algebraic-data-types-in-python">Algebraic Data Types in
Python</a></li>
<li><a href="#type-checking-and-pattern-matching" id="toc-type-checking-and-pattern-matching">Type Checking and Pattern
Matching</a></li>
</ul></li>
<li><a href="#section-4-applications-and-best-practices" id="toc-section-4-applications-and-best-practices">Section 4:
Applications and Best Practices</a>
<ul>
<li><a href="#when-to-use-type-annotations" id="toc-when-to-use-type-annotations">When to Use Type
Annotations</a></li>
<li><a href="#when-to-use-pattern-matching" id="toc-when-to-use-pattern-matching">When to Use Pattern
Matching</a></li>
<li><a href="#best-practices-for-type-annotations" id="toc-best-practices-for-type-annotations">Best Practices for Type
Annotations</a></li>
<li><a href="#best-practices-for-pattern-matching" id="toc-best-practices-for-pattern-matching">Best Practices for Pattern
Matching</a></li>
</ul></li>
<li><a href="#exercises" id="toc-exercises">Exercises</a></li>
<li><a href="#additional-resources" id="toc-additional-resources">Additional Resources</a></li>
</ul></li>
<li><a href="#chapter-3-building-a-mini-interpreter" id="toc-chapter-3-building-a-mini-interpreter">Chapter 3: Building a
Mini Interpreter</a>
<ul>
<li><a href="#section-1-introduction-to-interpreters" id="toc-section-1-introduction-to-interpreters">Section 1: Introduction
to Interpreters</a>
<ul>
<li><a href="#the-role-of-interpreters" id="toc-the-role-of-interpreters">The Role of Interpreters</a></li>
<li><a href="#components-of-an-interpreter" id="toc-components-of-an-interpreter">Components of an
Interpreter</a></li>
</ul></li>
<li><a href="#section-2-lexical-analysis" id="toc-section-2-lexical-analysis">Section 2: Lexical Analysis</a>
<ul>
<li><a href="#tokens-and-lexical-structure" id="toc-tokens-and-lexical-structure">Tokens and Lexical
Structure</a></li>
<li><a href="#implementing-a-lexer" id="toc-implementing-a-lexer">Implementing a Lexer</a></li>
<li><a href="#testing-the-lexer" id="toc-testing-the-lexer">Testing the
Lexer</a></li>
</ul></li>
<li><a href="#section-3-parsing-and-abstract-syntax-trees" id="toc-section-3-parsing-and-abstract-syntax-trees">Section 3: Parsing
and Abstract Syntax Trees</a>
<ul>
<li><a href="#understanding-abstract-syntax-trees" id="toc-understanding-abstract-syntax-trees">Understanding Abstract
Syntax Trees</a></li>
<li><a href="#defining-ast-nodes" id="toc-defining-ast-nodes">Defining
AST Nodes</a></li>
<li><a href="#implementing-a-recursive-descent-parser" id="toc-implementing-a-recursive-descent-parser">Implementing a
Recursive Descent Parser</a></li>
<li><a href="#testing-the-parser" id="toc-testing-the-parser">Testing
the Parser</a></li>
</ul></li>
<li><a href="#section-4-evaluating-expressions" id="toc-section-4-evaluating-expressions">Section 4: Evaluating
Expressions</a>
<ul>
<li><a href="#the-evaluation-process" id="toc-the-evaluation-process">The Evaluation Process</a></li>
<li><a href="#implementing-an-evaluator-1" id="toc-implementing-an-evaluator-1">Implementing an Evaluator</a></li>
<li><a href="#testing-the-evaluator" id="toc-testing-the-evaluator">Testing the Evaluator</a></li>
</ul></li>
<li><a href="#section-5-putting-it-all-together" id="toc-section-5-putting-it-all-together">Section 5: Putting It All
Together</a>
<ul>
<li><a href="#the-full-interpreter" id="toc-the-full-interpreter">The
Full Interpreter</a></li>
<li><a href="#example-usage" id="toc-example-usage">Example
Usage</a></li>
</ul></li>
<li><a href="#section-6-extending-the-interpreter" id="toc-section-6-extending-the-interpreter">Section 6: Extending the
Interpreter</a>
<ul>
<li><a href="#adding-variables" id="toc-adding-variables">Adding
Variables</a></li>
<li><a href="#new-ast-nodes-for-variables" id="toc-new-ast-nodes-for-variables">New AST Nodes for
Variables</a></li>
<li><a href="#updating-the-parser" id="toc-updating-the-parser">Updating
the Parser</a></li>
<li><a href="#updating-the-evaluator" id="toc-updating-the-evaluator">Updating the Evaluator</a></li>
<li><a href="#adding-control-flow" id="toc-adding-control-flow">Adding
Control Flow</a></li>
</ul></li>
<li><a href="#section-7-further-exploration" id="toc-section-7-further-exploration">Section 7: Further
Exploration</a>
<ul>
<li><a href="#additional-features-to-implement" id="toc-additional-features-to-implement">Additional Features to
Implement</a></li>
<li><a href="#learning-resources" id="toc-learning-resources">Learning
Resources</a></li>
</ul></li>
<li><a href="#conclusion" id="toc-conclusion">Conclusion</a></li>
</ul></li>
<li><a href="#chapter-4-semantic-domains-and-environment-based-interpreters" id="toc-chapter-4-semantic-domains-and-environment-based-interpreters">Chapter
4: Semantic Domains and Environment-Based Interpreters</a>
<ul>
<li><a href="#section-1-introduction-to-semantic-domains" id="toc-section-1-introduction-to-semantic-domains">Section 1:
Introduction to Semantic Domains</a>
<ul>
<li><a href="#key-semantic-domains-in-programming-languages" id="toc-key-semantic-domains-in-programming-languages">Key Semantic
Domains in Programming Languages</a></li>
<li><a href="#core-semantic-domains" id="toc-core-semantic-domains">Core
Semantic Domains</a></li>
<li><a href="#side-effects-and-pure-functions" id="toc-side-effects-and-pure-functions">Side Effects and Pure
Functions</a></li>
</ul></li>
<li><a href="#section-2-denotable-vs.-memorizable-values" id="toc-section-2-denotable-vs.-memorizable-values">Section 2: Denotable
vs. Memorizable Values</a>
<ul>
<li><a href="#denotable-values-dval" id="toc-denotable-values-dval">Denotable Values (DVal)</a></li>
<li><a href="#memorizable-values-mval" id="toc-memorizable-values-mval">Memorizable Values (MVal)</a></li>
</ul></li>
<li><a href="#section-3-environment-and-state-as-functions" id="toc-section-3-environment-and-state-as-functions">Section 3:
Environment and State as Functions</a>
<ul>
<li><a href="#functional-programming-a-brief-digression" id="toc-functional-programming-a-brief-digression">Functional
Programming: A Brief Digression</a></li>
<li><a href="#environment-as-a-function" id="toc-environment-as-a-function">Environment as a Function</a></li>
<li><a href="#state-as-a-dataclass" id="toc-state-as-a-dataclass">State
as a Dataclass</a></li>
</ul></li>
<li><a href="#section-4-functional-updates" id="toc-section-4-functional-updates">Section 4: Functional Updates</a>
<ul>
<li><a href="#environment-updates" id="toc-environment-updates">Environment Updates</a></li>
<li><a href="#state-updates" id="toc-state-updates">State
Updates</a></li>
<li><a href="#empty-environment-and-state" id="toc-empty-environment-and-state">Empty Environment and
State</a></li>
<li><a href="#memory-allocation" id="toc-memory-allocation">Memory
Allocation</a></li>
<li><a href="#initial-environment-setup" id="toc-initial-environment-setup">Initial Environment Setup</a></li>
</ul></li>
<li><a href="#section-5-environment-based-interpretation" id="toc-section-5-environment-based-interpretation">Section 5:
Environment-Based Interpretation</a>
<ul>
<li><a href="#traditional-approach-from-chapter-3" id="toc-traditional-approach-from-chapter-3">Traditional Approach (from
Chapter 3)</a></li>
<li><a href="#environment-based-approach" id="toc-environment-based-approach">Environment-Based Approach</a></li>
<li><a href="#benefits-of-the-environment-based-approach" id="toc-benefits-of-the-environment-based-approach">Benefits of the
Environment-Based Approach</a></li>
</ul></li>
<li><a href="#section-6-implementing-an-environment-based-interpreter" id="toc-section-6-implementing-an-environment-based-interpreter">Section
6: Implementing an Environment-Based Interpreter</a></li>
<li><a href="#section-7-extending-the-interpreter" id="toc-section-7-extending-the-interpreter">Section 7: Extending the
Interpreter</a>
<ul>
<li><a href="#adding-new-operators" id="toc-adding-new-operators">Adding
New Operators</a></li>
</ul></li>
</ul></li>
<li><a href="#update-evaluate-function" id="toc-update-evaluate-function">Update evaluate function</a>
<ul>
<li><a href="#additional-resources-1" id="toc-additional-resources-1">Additional Resources</a></li>
<li><a href="#section-9-practical-implementation-and-testing" id="toc-section-9-practical-implementation-and-testing">Section 9:
Practical Implementation and Testing</a>
<ul>
<li><a href="#parsing-and-ast-construction" id="toc-parsing-and-ast-construction">Parsing and AST
Construction</a></li>
<li><a href="#interactive-repl" id="toc-interactive-repl">Interactive
REPL</a></li>
<li><a href="#automated-tests" id="toc-automated-tests">Automated
Tests</a></li>
</ul></li>
<li><a href="#section-10-conclusion-and-next-steps" id="toc-section-10-conclusion-and-next-steps">Section 10: Conclusion and
Next Steps</a>
<ul>
<li><a href="#summary-of-key-concepts" id="toc-summary-of-key-concepts">Summary of Key Concepts</a></li>
<li><a href="#looking-forward" id="toc-looking-forward">Looking
Forward</a></li>
<li><a href="#exercises-for-the-reader" id="toc-exercises-for-the-reader">Exercises for the Reader</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-5-variable-binding-and-let-expressions" id="toc-chapter-5-variable-binding-and-let-expressions">Chapter 5:
Variable Binding and Let Expressions</a>
<ul>
<li><a href="#section-1-introduction-to-variable-binding" id="toc-section-1-introduction-to-variable-binding">Section 1:
Introduction to Variable Binding</a>
<ul>
<li><a href="#variable-binding-vs.-assignment" id="toc-variable-binding-vs.-assignment">Variable Binding
vs. Assignment</a></li>
</ul></li>
<li><a href="#section-2-let-expressions" id="toc-section-2-let-expressions">Section 2: Let Expressions</a>
<ul>
<li><a href="#syntax-and-semantics-of-let-expressions" id="toc-syntax-and-semantics-of-let-expressions">Syntax and Semantics of
Let Expressions</a></li>
<li><a href="#ast-representation" id="toc-ast-representation">AST
Representation</a></li>
<li><a href="#variable-references" id="toc-variable-references">Variable
References</a></li>
</ul></li>
<li><a href="#section-3-the-environment" id="toc-section-3-the-environment">Section 3: The Environment</a>
<ul>
<li><a href="#environment-as-a-first-class-citizen" id="toc-environment-as-a-first-class-citizen">Environment as a
First-Class Citizen</a></li>
<li><a href="#environment-implementation" id="toc-environment-implementation">Environment Implementation</a></li>
<li><a href="#static-vs.-dynamic-scoping" id="toc-static-vs.-dynamic-scoping">Static vs. Dynamic Scoping</a></li>
</ul></li>
<li><a href="#section-5-conclusion" id="toc-section-5-conclusion">Section 5: Conclusion</a>
<ul>
<li><a href="#parser-and-grammar-extensions" id="toc-parser-and-grammar-extensions">Parser and Grammar
Extensions</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-6-state" id="toc-chapter-6-state">Chapter 6:
State</a>
<ul>
<li><a href="#section-1-introduction-to-state" id="toc-section-1-introduction-to-state">Section 1: Introduction to
State</a>
<ul>
<li><a href="#expressions-vs.-commands" id="toc-expressions-vs.-commands">Expressions vs. Commands</a></li>
</ul></li>
<li><a href="#section-2-commands-and-command-sequences" id="toc-section-2-commands-and-command-sequences">Section 2: Commands
and Command Sequences</a>
<ul>
<li><a href="#commands-in-our-language" id="toc-commands-in-our-language">Commands in Our Language</a></li>
<li><a href="#command-sequences" id="toc-command-sequences">Command
Sequences</a></li>
<li><a href="#grammar-extensions" id="toc-grammar-extensions">Grammar
Extensions</a></li>
<li><a href="#ast-representation-1" id="toc-ast-representation-1">AST
Representation</a></li>
</ul></li>
<li><a href="#section-3-the-store-model-of-state" id="toc-section-3-the-store-model-of-state">Section 3: The Store Model
of State</a>
<ul>
<li><a href="#the-state-as-a-functional-dataclass" id="toc-the-state-as-a-functional-dataclass">The State as a Functional
Dataclass</a></li>
<li><a href="#denotable-values-dval-1" id="toc-denotable-values-dval-1">Denotable Values (DVal)</a></li>
</ul></li>
<li><a href="#section-4-evaluating-expressions-with-state" id="toc-section-4-evaluating-expressions-with-state">Section 4:
Evaluating Expressions with State</a></li>
<li><a href="#section-5-executing-commands" id="toc-section-5-executing-commands">Section 5: Executing Commands</a>
<ul>
<li><a href="#the-variable-declaration-command" id="toc-the-variable-declaration-command">The Variable Declaration
Command</a></li>
<li><a href="#the-assignment-command" id="toc-the-assignment-command">The Assignment Command</a></li>
<li><a href="#the-print-command" id="toc-the-print-command">The Print
Command</a></li>
<li><a href="#command-sequences-1" id="toc-command-sequences-1">Command
Sequences</a></li>
</ul></li>
<li><a href="#section-6-examples-of-state-in-action" id="toc-section-6-examples-of-state-in-action">Section 6: Examples of
State in Action</a>
<ul>
<li><a href="#example-1-basic-declaration-assignment-and-printing" id="toc-example-1-basic-declaration-assignment-and-printing">Example 1:
Basic Declaration, Assignment, and Printing</a></li>
<li><a href="#example-2-updating-variables" id="toc-example-2-updating-variables">Example 2: Updating
Variables</a></li>
<li><a href="#example-3-multiple-declarations-and-operations" id="toc-example-3-multiple-declarations-and-operations">Example 3:
Multiple Declarations and Operations</a></li>
<li><a href="#example-4-let-expressions-in-commands" id="toc-example-4-let-expressions-in-commands">Example 4: Let
Expressions in Commands</a></li>
</ul></li>
<li><a href="#section-7-differences-from-previous-chapters" id="toc-section-7-differences-from-previous-chapters">Section 7:
Differences from Previous Chapters</a></li>
<li><a href="#section-8-conclusion-and-next-steps" id="toc-section-8-conclusion-and-next-steps">Section 8: Conclusion and
Next Steps</a></li>
<li><a href="#exercises-1" id="toc-exercises-1">Exercises</a>
<ul>
<li><a href="#interactive-repl-1" id="toc-interactive-repl-1">1)
Interactive REPL</a></li>
<li><a href="#aliasing" id="toc-aliasing">2) Aliasing</a></li>
<li><a href="#multiple-assignment" id="toc-multiple-assignment">3)
Multiple Assignment</a></li>
<li><a href="#parallel-assignment" id="toc-parallel-assignment">4)
Parallel Assignment</a></li>
<li><a href="#if-then-else-statements" id="toc-if-then-else-statements">5) If-Then-Else Statements</a></li>
<li><a href="#command-sequences-in-branches" id="toc-command-sequences-in-branches">5) Command Sequences in
Branches</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-7-control-flow" id="toc-chapter-7-control-flow">Chapter 7: Control Flow</a>
<ul>
<li><a href="#introduction-to-control-flow" id="toc-introduction-to-control-flow">1. Introduction to Control
Flow</a></li>
<li><a href="#control-flow-constructs" id="toc-control-flow-constructs">2. Control Flow Constructs</a>
<ul>
<li><a href="#if-then-else" id="toc-if-then-else">2.1
If-Then-Else</a></li>
<li><a href="#while-loops" id="toc-while-loops">2.2 While Loops</a></li>
</ul></li>
<li><a href="#block-local-variables-and-scoping" id="toc-block-local-variables-and-scoping">3. Block-Local Variables and
Scoping</a>
<ul>
<li><a href="#digression-memory-safety-and-buffer-over-read" id="toc-digression-memory-safety-and-buffer-over-read">Digression:
Memory Safety and Buffer Over-Read</a></li>
</ul></li>
<li><a href="#unified-operators-and-boolean-expressions" id="toc-unified-operators-and-boolean-expressions">4. Unified Operators
and Boolean Expressions</a></li>
<li><a href="#grammar-extensions-1" id="toc-grammar-extensions-1">5.
Grammar Extensions</a></li>
<li><a href="#abstract-syntax-tree-ast-extensions" id="toc-abstract-syntax-tree-ast-extensions">6. Abstract Syntax Tree
(AST) Extensions</a></li>
<li><a href="#ast-and-semantics-of-operators" id="toc-ast-and-semantics-of-operators">6.1 AST and Semantics of
Operators</a>
<ul>
<li><a href="#ast-node-for-operators" id="toc-ast-node-for-operators">AST Node for Operators</a></li>
<li><a href="#operator-class" id="toc-operator-class">Operator
Class</a></li>
<li><a href="#semantics-of-operator-application" id="toc-semantics-of-operator-application">Semantics of Operator
Application</a></li>
<li><a href="#example-operator-application" id="toc-example-operator-application">Example: Operator
Application</a></li>
<li><a href="#runtime-type-and-arity-checks" id="toc-runtime-type-and-arity-checks">Runtime Type and Arity
Checks</a></li>
</ul></li>
<li><a href="#examples-of-control-flow-in-action" id="toc-examples-of-control-flow-in-action">7. Examples of Control Flow
in Action</a>
<ul>
<li><a href="#example-1-if-then-else" id="toc-example-1-if-then-else">Example 1: If-Then-Else</a></li>
<li><a href="#example-2-while-loop" id="toc-example-2-while-loop">Example 2: While Loop</a></li>
<li><a href="#example-3-euclids-algorithm-gcd-using-subtraction" id="toc-example-3-euclids-algorithm-gcd-using-subtraction">Example 3:
Euclid’s Algorithm (GCD) Using Subtraction</a></li>
</ul></li>
<li><a href="#comparison-with-previous-chapters" id="toc-comparison-with-previous-chapters">8. Comparison with Previous
Chapters</a></li>
<li><a href="#conclusion-and-next-steps" id="toc-conclusion-and-next-steps">9. Conclusion and Next Steps</a></li>
<li><a href="#exercises-2" id="toc-exercises-2">10. Exercises</a></li>
<li><a href="#appendix-closures-denotable-values-and-state" id="toc-appendix-closures-denotable-values-and-state">Appendix:
Closures, Denotable Values, and State</a>
<ul>
<li><a href="#why-closures-are-special" id="toc-why-closures-are-special">Why Closures Are Special</a></li>
<li><a href="#special-provisions-for-closures" id="toc-special-provisions-for-closures">Special Provisions for
Closures</a></li>
<li><a href="#in-our-mini-language" id="toc-in-our-mini-language">In Our
Mini-Language</a></li>
</ul></li>
<li><a href="#example-the-danger-of-memorizing-closures" id="toc-example-the-danger-of-memorizing-closures">Example: The Danger
of Memorizing Closures</a></li>
</ul></li>
</ul>
</nav>
<h1 id="chapter-1-introduction-to-programming-language-design">Chapter
1: Introduction to Programming Language Design</h1>
<h2 id="section-1-what-is-a-programming-language">Section 1: What is a
Programming Language?</h2>
<p>A <strong>programming language</strong> is a formal language
comprising a set of strings (instructions) that produce various kinds of
machine output. Programming languages are used in computer programming
to implement algorithms.</p>
<h3 id="key-characteristics-of-programming-languages">Key
Characteristics of Programming Languages</h3>
<ul>
<li><strong>Syntax</strong>: The form or structure of the expressions,
statements, and program units</li>
<li><strong>Semantics</strong>: The meaning of the expressions,
statements, and program units</li>
<li><strong>Type System</strong>: The set of types and rules for how
types are assigned to various constructs in the language</li>
<li><strong>Runtime Model</strong>: How the language executes on a
computer, including memory management</li>
<li><strong>Standard Library</strong>: Common functionality provided out
of the box</li>
</ul>
<h3 id="programming-languages-vs.-natural-languages">Programming
Languages vs. Natural Languages</h3>
<p>Programming languages differ from natural languages in several
important ways:</p>
<ol type="1">
<li><strong>Precision</strong>: Programming languages are designed to be
precise and unambiguous</li>
<li><strong>Vocabulary</strong>: Programming languages have a limited
vocabulary defined by the language specification</li>
<li><strong>Grammar</strong>: Programming languages have a strict,
formal grammar with precise rules</li>
<li><strong>Evolution</strong>: Programming languages evolve through
explicit design decisions, not organic usage</li>
<li><strong>Purpose</strong>: Programming languages are designed to
instruct machines, not primarily for human communication</li>
</ol>
<h2 id="section-2-the-importance-of-programming-language-design">Section
2: The Importance of Programming Language Design</h2>
<p>Why should we care about programming language design?</p>
<h3 id="programming-languages-shape-how-we-think">Programming Languages
Shape How We Think</h3>
<p>Programming languages are not just tools for instructing computers;
they are frameworks for human thinking. Different languages emphasize
different concepts and approaches:</p>
<ul>
<li><strong>Imperative languages</strong> (C, Pascal) focus on
step-by-step instructions</li>
<li><strong>Functional languages</strong> (Haskell, Lisp) emphasize
expressions and function composition</li>
<li><strong>Object-oriented languages</strong> (Java, C++, Python)
organize code around objects and their interactions</li>
<li><strong>Logic languages</strong> (Prolog) express programs as
logical relations</li>
</ul>
<h3 id="language-design-affects-software-quality">Language Design
Affects Software Quality</h3>
<p>The design of a programming language can significantly impact:</p>
<ul>
<li><strong>Reliability</strong>: How easy is it to write correct
code?</li>
<li><strong>Maintainability</strong>: How easy is it to understand and
modify existing code?</li>
<li><strong>Performance</strong>: How efficiently can the code be
executed?</li>
<li><strong>Security</strong>: How easily can programmers avoid security
vulnerabilities?</li>
<li><strong>Developer Productivity</strong>: How quickly can developers
write and debug code?</li>
</ul>
<h3 id="the-evolution-of-programming-languages">The Evolution of
Programming Languages</h3>
<p>Programming languages have evolved dramatically over time, reflecting
changes in hardware, software engineering practices, and problem
domains:</p>
<ul>
<li><strong>1950s</strong>: Assembly languages and early high-level
languages (FORTRAN, LISP)</li>
<li><strong>1960s</strong>: ALGOL, COBOL, and structured programming
concepts</li>
<li><strong>1970s</strong>: C, Pascal, and the rise of procedural
programming</li>
<li><strong>1980s</strong>: C++, Ada, and the adoption of
object-oriented programming</li>
<li><strong>1990s</strong>: Java, Python, Ruby, and the focus on
portability and productivity</li>
<li><strong>2000s</strong>: C#, JavaScript frameworks, and web-centric
languages</li>
<li><strong>2010s</strong>: Go, Rust, Swift, and the focus on safety and
concurrency</li>
<li><strong>2020s</strong>: Continued evolution with AI assistance, type
inference improvements, and more</li>
</ul>
<h2 id="section-3-modern-language-design-principles">Section 3: Modern
Language Design Principles</h2>
<p>What principles guide the design of modern programming languages?</p>
<h3 id="abstraction">Abstraction</h3>
<p>Abstraction is the process of removing details to focus on the
essential features of a concept or object.</p>
<p><strong>Examples in programming languages</strong>: - Functions
abstract away implementation details - Classes abstract data and
behavior - Interfaces abstract expected behaviors - Modules abstract
related functionality</p>
<h3 id="expressiveness">Expressiveness</h3>
<p>Expressiveness refers to how easily and concisely a language can
express computational ideas.</p>
<p><strong>Factors that contribute to expressiveness</strong>: - Rich
set of operators and built-in functions - Support for higher-order
functions - Pattern matching - Concise syntax for common operations</p>
<h3 id="safety">Safety</h3>
<p>Safety features help prevent programmers from making mistakes or make
it easier to find and fix errors.</p>
<p><strong>Safety mechanisms in modern languages</strong>: - Static type
checking - Bounds checking - Memory safety guarantees - Exception
handling systems - Null safety features</p>
<h3 id="performance">Performance</h3>
<p>Performance considerations affect how efficiently a language can be
implemented and executed.</p>
<p><strong>Performance factors</strong>: - Compilation
vs. interpretation - Memory management approach - Static vs. dynamic
typing - Optimization opportunities - Support for concurrency and
parallelism</p>
<h3 id="consistency">Consistency</h3>
<p>Consistency in language design makes languages easier to learn and
use correctly.</p>
<p><strong>Consistency principles</strong>: - Similar concepts should
have similar syntax - Minimal special cases - Orthogonal features
(features that can be used in any combination) - Principle of least
surprise (intuitive behavior)</p>
<h2 id="section-4-using-python-to-explore-programming-language-concepts">Section
4: Using Python to Explore Programming Language Concepts</h2>
<p>Why use Python for studying programming language design?</p>
<h3 id="pythons-suitability-for-language-implementation">Python’s
Suitability for Language Implementation</h3>
<p>Python is well-suited for implementing language interpreters and
exploring language concepts:</p>
<ul>
<li><strong>Readability</strong>: Python’s clean syntax makes
interpreter code easier to understand</li>
<li><strong>High-level constructs</strong>: Python provides lists,
dictionaries, and other structures useful for language
implementation</li>
<li><strong>Dynamic typing</strong>: Simplifies working with diverse
language constructs</li>
<li><strong>Rich standard library</strong>: Includes parsing tools,
regular expressions, and other useful utilities</li>
<li><strong>Interactive development</strong>: Makes experimenting with
language features easier</li>
</ul>
<h3 id="python-3.10-features-relevant-to-language-design">Python 3.10+
Features Relevant to Language Design</h3>
<p>Recent Python versions have introduced features that make it
particularly interesting for PL experiments:</p>
<ul>
<li><strong>Type hints</strong>: Allows for static type checking while
maintaining dynamic execution</li>
<li><strong>Pattern matching</strong>: Provides elegant structural
decomposition similar to functional languages</li>
<li><strong>Dataclasses</strong>: Simplifies creating data-carrying
classes with minimal boilerplate</li>
<li><strong>Functional programming tools</strong>: Map, filter, reduce,
lambdas, and comprehensions</li>
<li><strong>AST module</strong>: Allows inspection and manipulation of
Python’s abstract syntax tree</li>
</ul>
<h2 id="section-5-implementing-language-features-in-python">Section 5:
Implementing Language Features in Python</h2>
<p>Let’s explore how we can implement core language components in
Python.</p>
<h3 id="representing-syntax-abstract-syntax-trees-asts">Representing
Syntax: Abstract Syntax Trees (ASTs)</h3>
<p>An abstract syntax tree (AST) is a tree representation of the
abstract syntactic structure of source code. Here’s a simple example of
representing expressions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dataclasses <span class="im">import</span> dataclass</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Union, List</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the node types</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Number:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    value: <span class="bu">float</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Variable:</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BinaryOp:</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    left: <span class="st">&#39;Expr&#39;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    operator: <span class="bu">str</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    right: <span class="st">&#39;Expr&#39;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the expression type</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>Expr <span class="op">=</span> Union[Number, Variable, BinaryOp]</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: 2 + (x * 3)</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>expr <span class="op">=</span> BinaryOp(</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    left<span class="op">=</span>Number(<span class="fl">2.0</span>),</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    operator<span class="op">=</span><span class="st">&#39;+&#39;</span>,</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    right<span class="op">=</span>BinaryOp(</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        left<span class="op">=</span>Variable(<span class="st">&#39;x&#39;</span>),</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        operator<span class="op">=</span><span class="st">&#39;*&#39;</span>,</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        right<span class="op">=</span>Number(<span class="fl">3.0</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<h3 id="implementing-an-evaluator">Implementing an Evaluator</h3>
<p>The evaluator traverses the AST and computes the result. For
example:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate(expr: Expr, environment: <span class="bu">dict</span> <span class="op">=</span> <span class="va">None</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Evaluate an expression in the given environment.&quot;&quot;&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> environment <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        environment <span class="op">=</span> {}</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(expr, Number):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> expr.value</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(expr, Variable):</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> expr.name <span class="kw">not</span> <span class="kw">in</span> environment:</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">NameError</span>(<span class="ss">f&quot;Variable &#39;</span><span class="sc">{</span>expr<span class="sc">.</span>name<span class="sc">}</span><span class="ss">&#39; not defined&quot;</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> environment[expr.name]</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(expr, BinaryOp):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        left_val <span class="op">=</span> evaluate(expr.left, environment)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        right_val <span class="op">=</span> evaluate(expr.right, environment)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> expr.operator <span class="op">==</span> <span class="st">&#39;+&#39;</span>:</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> left_val <span class="op">+</span> right_val</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> expr.operator <span class="op">==</span> <span class="st">&#39;-&#39;</span>:</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> left_val <span class="op">-</span> right_val</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> expr.operator <span class="op">==</span> <span class="st">&#39;*&#39;</span>:</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> left_val <span class="op">*</span> right_val</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> expr.operator <span class="op">==</span> <span class="st">&#39;/&#39;</span>:</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> left_val <span class="op">/</span> right_val</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Unknown operator: </span><span class="sc">{</span>expr<span class="sc">.</span>operator<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="pattern-matching-for-ast-processing">Pattern Matching for AST
Processing</h3>
<p>Python 3.10’s pattern matching provides a more elegant way to
implement evaluators:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_with_match(expr: Expr, environment: <span class="bu">dict</span> <span class="op">=</span> <span class="va">None</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Evaluate an expression using pattern matching.&quot;&quot;&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> environment <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        environment <span class="op">=</span> {}</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> expr:</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Number(value):</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> value</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Variable(name):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> name <span class="kw">not</span> <span class="kw">in</span> environment:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">NameError</span>(<span class="ss">f&quot;Variable &#39;</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&#39; not defined&quot;</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> environment[name]</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> BinaryOp(left, operator, right):</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            left_val <span class="op">=</span> evaluate_with_match(left, environment)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>            right_val <span class="op">=</span> evaluate_with_match(right, environment)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> operator:</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">case</span> <span class="st">&#39;+&#39;</span>:</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> left_val <span class="op">+</span> right_val</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">case</span> <span class="st">&#39;-&#39;</span>:</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> left_val <span class="op">-</span> right_val</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">case</span> <span class="st">&#39;*&#39;</span>:</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> left_val <span class="op">*</span> right_val</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>                <span class="cf">case</span> <span class="st">&#39;/&#39;</span>:</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> left_val <span class="op">/</span> right_val</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">case</span> _:</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Unknown operator: </span><span class="sc">{</span>operator<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="simple-type-checking">Simple Type Checking</h3>
<p>We can implement basic type checking for our language:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> enum <span class="im">import</span> Enum, auto</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dataclasses <span class="im">import</span> dataclass</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Dict</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Type(Enum):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    NUMBER <span class="op">=</span> auto()</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    BOOLEAN <span class="op">=</span> auto()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    STRING <span class="op">=</span> auto()</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> type_check(expr: Expr, type_env: Dict[<span class="bu">str</span>, Type]) <span class="op">-&gt;</span> Type:</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Determine the type of an expression.&quot;&quot;&quot;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> expr:</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Number(_):</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Type.NUMBER</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Variable(name):</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> name <span class="kw">not</span> <span class="kw">in</span> type_env:</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="ss">f&quot;Variable &#39;</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&#39; not defined&quot;</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> type_env[name]</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> BinaryOp(left, operator, right):</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>            left_type <span class="op">=</span> type_check(left, type_env)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>            right_type <span class="op">=</span> type_check(right, type_env)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Type checking rules for operators</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> operator <span class="kw">in</span> [<span class="st">&#39;+&#39;</span>, <span class="st">&#39;-&#39;</span>, <span class="st">&#39;*&#39;</span>, <span class="st">&#39;/&#39;</span>]:</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> left_type <span class="op">!=</span> Type.NUMBER <span class="kw">or</span> right_type <span class="op">!=</span> Type.NUMBER:</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="ss">f&quot;Operator &#39;</span><span class="sc">{</span>operator<span class="sc">}</span><span class="ss">&#39; requires number operands&quot;</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> Type.NUMBER</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> operator <span class="kw">in</span> [<span class="st">&#39;==&#39;</span>, <span class="st">&#39;!=&#39;</span>, <span class="st">&#39;&lt;&#39;</span>, <span class="st">&#39;&gt;&#39;</span>, <span class="st">&#39;&lt;=&#39;</span>, <span class="st">&#39;&gt;=&#39;</span>]:</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> left_type <span class="op">!=</span> right_type:</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="st">&quot;Comparison operators require operands of the same type&quot;</span>)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> Type.BOOLEAN</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Unknown operator: </span><span class="sc">{</span>operator<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h2 id="section-6-course-structure">Section 6: Course Structure</h2>
<p>This course will introduce you to programming language design
concepts through hands-on implementation in Python.</p>
<h3 id="course-topics">Course Topics</h3>
<p>Throughout this course, we will cover:</p>
<ol type="1">
<li><strong>Language Syntax and Semantics</strong>
<ul>
<li>Parsing and lexical analysis</li>
<li>Abstract syntax trees</li>
<li>Operational semantics</li>
</ul></li>
<li><strong>Type Systems</strong>
<ul>
<li>Static vs. dynamic typing</li>
<li>Type inference</li>
<li>Polymorphism</li>
<li>Advanced type features (generics, algebraic data types)</li>
</ul></li>
<li><strong>Language Features</strong>
<ul>
<li>Functions and closures</li>
<li>Pattern matching</li>
<li>Object-oriented programming</li>
<li>Concurrency models</li>
<li>Memory management approaches</li>
</ul></li>
<li><strong>Interpreter and Compiler Implementation</strong>
<ul>
<li>Building a simple interpreter</li>
<li>Environment and scope</li>
<li>Evaluation strategies</li>
<li>Introduction to compilation concepts</li>
</ul></li>
</ol>
<h3 id="projects-and-exercises">Projects and Exercises</h3>
<p>The course will include:</p>
<ul>
<li>Regular programming exercises to reinforce concepts</li>
<li>Progressive development of a language interpreter</li>
<li>Exploration of existing language implementations</li>
<li>Analysis of language design trade-offs</li>
</ul>
<h2 id="section-7-prerequisites-and-setup">Section 7: Prerequisites and
Setup</h2>
<h3 id="knowledge-prerequisites">Knowledge Prerequisites</h3>
<p>To get the most out of this course, you should have:</p>
<ul>
<li>Basic Python programming experience</li>
<li>Understanding of fundamental programming concepts (variables,
functions, control flow)</li>
<li>Familiarity with basic data structures (lists, dictionaries,
trees)</li>
<li>Interest in how programming languages work “under the hood”</li>
</ul>
<p>No prior experience with compiler or interpreter development is
required.</p>
<h3 id="python-environment-setup">Python Environment Setup</h3>
<p>To follow along with the course examples and exercises:</p>
<ol type="1">
<li><strong>Install Python 3.10 or later</strong>
<ul>
<li>Required for pattern matching and other modern features</li>
</ul></li>
<li><strong>Recommended development tools</strong>
<ul>
<li>Visual Studio Code with Python extension</li>
<li>PyCharm</li>
<li>Jupyter Notebook/Lab for interactive exploration</li>
</ul></li>
<li><strong>Useful libraries</strong>
<ul>
<li>mypy for static type checking</li>
<li>pytest for testing your implementations</li>
</ul></li>
</ol>
<h2 id="section-8-additional-resources">Section 8: Additional
Resources</h2>
<h3 id="books-on-programming-language-design">Books on Programming
Language Design</h3>
<ul>
<li><strong>“Crafting Interpreters”</strong> by Robert Nystrom</li>
<li><strong>“Programming Language Pragmatics”</strong> by Michael
Scott</li>
<li><strong>“Types and Programming Languages”</strong> by Benjamin
Pierce</li>
<li><strong>“Concepts of Programming Languages”</strong> by Robert
Sebesta</li>
<li><strong>“Structure and Interpretation of Computer Programs”</strong>
by Abelson and Sussman</li>
</ul>
<h3 id="online-resources">Online Resources</h3>
<ul>
<li><a href="https://docs.python.org/3/">Python Documentation</a></li>
<li><a href="https://docs.python.org/3/library/typing.html">Python Type
Hints</a></li>
<li><a href="https://docs.python.org/3/whatsnew/3.10.html#pep-634-structural-pattern-matching">Pattern
Matching in Python 3.10</a></li>
<li><a href="https://docs.python.org/3/library/ast.html">The AST
Module</a></li>
<li><a href="https://ruslanspivak.com/lsbasi-part1/">Building a Simple
Interpreter</a></li>
</ul>
<h1 id="chapter-2-types-and-pattern-matching-in-python">Chapter 2: Types
and Pattern Matching in Python</h1>
<h2 id="section-1-pythons-type-system">Section 1: Python’s Type
System</h2>
<h3 id="what-are-type-annotations">What are Type Annotations?</h3>
<p>Python’s type system allows developers to add optional type hints to
variables, function parameters, and return values. These annotations
help catch errors early, improve code documentation, and enhance IDE
support without changing the runtime behavior of the code.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> greet(name: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ss">f&quot;Hello, </span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">!&quot;</span></span></code></pre></div>
<p>Type annotations are part of the Python Enhancement Proposal (PEP)
484 and have been continuously improved in subsequent PEPs. They provide
a way to make Python code more robust through static type checking,
although Python remains dynamically typed at runtime.</p>
<h3 id="basic-types-in-python">Basic Types in Python</h3>
<p>Python provides several built-in types for annotations:</p>
<ul>
<li><strong>Primitive types</strong>: <code>int</code>,
<code>float</code>, <code>bool</code>, <code>str</code></li>
<li><strong>Collection types</strong>: <code>list</code>,
<code>tuple</code>, <code>dict</code>, <code>set</code></li>
</ul>
<p>Example from <code>types_and_matching.py</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>my_tuple: <span class="bu">tuple</span>[<span class="bu">int</span>, <span class="bu">str</span>, <span class="bu">float</span>] <span class="op">=</span> (<span class="dv">1</span>, <span class="st">&quot;hello&quot;</span>, <span class="fl">1.0</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>my_list: <span class="bu">list</span>[<span class="bu">int</span>] <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span></code></pre></div>
<p>These annotations tell the type checker that <code>my_tuple</code> is
a 3-element tuple containing an integer, a string, and a float, while
<code>my_list</code> is a list containing only integers.</p>
<h3 id="generic-types">Generic Types</h3>
<p>Generic types allow you to create reusable, type-safe components. In
Python 3.12+, the syntax for generic classes uses square brackets:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Stack[T]:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.items: <span class="bu">list</span>[T] <span class="op">=</span> []</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> push(<span class="va">self</span>, item: T) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.items.append(item)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> pop(<span class="va">self</span>) <span class="op">-&gt;</span> T <span class="op">|</span> <span class="va">None</span>:</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.items.pop() <span class="cf">if</span> <span class="va">self</span>.items <span class="cf">else</span> <span class="va">None</span></span></code></pre></div>
<p>In this example from our code: - <code>T</code> is a type parameter
representing any type - <code>Stack[T]</code> is a generic class that
can be specialized for specific types - <code>list[T]</code> indicates a
list containing elements of type <code>T</code></p>
<p>To use this generic class:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>stack_1 <span class="op">=</span> Stack[<span class="bu">int</span>]()  <span class="co"># A stack of integers</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>stack_1.push(<span class="dv">1</span>)  <span class="co"># Valid</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>stack_1.push(<span class="st">&quot;hello&quot;</span>)  <span class="co"># Type error: expected int, got str</span></span></code></pre></div>
<h3 id="union-types-and-optional-values">Union Types and Optional
Values</h3>
<p>Union types allow a variable to have multiple possible types,
expressed using the <code>|</code> operator (introduced in Python
3.10):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> process_data(data: <span class="bu">int</span> <span class="op">|</span> <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Can handle both integers and strings</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code></pre></div>
<p>From our example code:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pop(<span class="va">self</span>) <span class="op">-&gt;</span> T <span class="op">|</span> <span class="va">None</span>:  <span class="co"># Use | for union types</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">self</span>.items.pop() <span class="cf">if</span> <span class="va">self</span>.items <span class="cf">else</span> <span class="va">None</span></span></code></pre></div>
<p>This indicates that the <code>pop</code> method returns either a
value of type <code>T</code> or <code>None</code> if the stack is
empty.</p>
<h3 id="type-aliases">Type Aliases</h3>
<p>Type aliases help simplify complex type annotations:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> JsonData <span class="op">=</span> <span class="bu">dict</span>[<span class="bu">str</span>, <span class="bu">int</span> <span class="op">|</span> <span class="bu">str</span> <span class="op">|</span> <span class="bu">list</span> <span class="op">|</span> <span class="bu">dict</span>]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> A <span class="op">=</span> <span class="bu">int</span> <span class="op">|</span> <span class="bu">dict</span>[<span class="bu">str</span>, A]  <span class="co"># Recursive type</span></span></code></pre></div>
<p>In <code>types_and_matching.py</code>, we use type aliases for
recursive types:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> MyBaseList[T] <span class="op">=</span> <span class="va">None</span> <span class="op">|</span> MyList[T]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> Expr <span class="op">=</span> <span class="bu">int</span> <span class="op">|</span> Sum</span></code></pre></div>
<p>These aliases make the code more readable and allow for recursive
type definitions.</p>
<h3 id="literal-types">Literal Types</h3>
<p>Literal types restrict values to specific constants:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>y: Literal[<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;world&quot;</span>] <span class="op">=</span> <span class="st">&quot;hello&quot;</span>  <span class="co"># Valid</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>z: Literal[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] <span class="op">=</span> <span class="dv">9</span>  <span class="co"># Type error</span></span></code></pre></div>
<p>From our example code:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Human:</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    drivingLicense: Literal[<span class="va">True</span>, <span class="va">False</span>]</span></code></pre></div>
<p>This constrains the <code>drivingLicense</code> attribute to be
either <code>True</code> or <code>False</code> only.</p>
<h2 id="section-2-structural-pattern-matching">Section 2: Structural
Pattern Matching</h2>
<h3 id="introduction-to-pattern-matching">Introduction to Pattern
Matching</h3>
<p>Introduced in Python 3.10, the <code>match</code> statement provides
powerful pattern matching capabilities, similar to switch statements in
other languages but with more expressive power:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> describe(value):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> value:</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">0</span>:</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;Zero&quot;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="bu">int</span>(x) <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;Positive integer&quot;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="bu">str</span>():</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;String&quot;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> _:</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;Something else&quot;</span></span></code></pre></div>
<p>Pattern matching allows for more concise and readable code,
especially when dealing with complex data structures and multiple
conditions.</p>
<h3 id="basic-patterns">Basic Patterns</h3>
<p>Basic patterns match against simple values and types:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="cf">match</span> x:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">0</span>:</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;Zero&quot;</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="bu">int</span>():</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;Integer&quot;</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="bu">str</span>():</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;String&quot;</span>)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> _:  <span class="co"># Wildcard pattern</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;Something else&quot;</span>)</span></code></pre></div>
<p>The <code>_</code> pattern is a wildcard that matches anything and is
often used as a catch-all case.</p>
<h3 id="sequence-patterns">Sequence Patterns</h3>
<p>Sequence patterns match against sequence types like lists and
tuples:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> process_lst(lst: <span class="bu">list</span>[<span class="bu">int</span>]) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> lst:</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        case []:</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">&quot;List: empty&quot;</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        case [head, <span class="op">*</span>tail]:</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;List: head </span><span class="sc">{</span>head<span class="sc">}</span><span class="ss">, tail </span><span class="sc">{</span>tail<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<p>This example shows destructuring a list into its head (first element)
and tail (remaining elements), demonstrating how pattern matching
facilitates recursive list processing.</p>
<h3 id="class-patterns-and-attribute-matching">Class Patterns and
Attribute Matching</h3>
<p>Pattern matching works particularly well with dataclasses:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> greet(person: Person <span class="op">|</span> <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> person:</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Person(name<span class="op">=</span><span class="st">&quot;Alice&quot;</span>, age<span class="op">=</span><span class="dv">25</span>):</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">&quot;Hello Alice!&quot;</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Person(name<span class="op">=</span>x, age<span class="op">=</span>y):</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;Hello </span><span class="sc">{</span>x<span class="sc">}</span><span class="ss"> of age </span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">!&quot;</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="bu">str</span>():</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;Hello </span><span class="sc">{</span>person<span class="sc">}</span><span class="ss">!&quot;</span>)</span></code></pre></div>
<p>This example shows matching against specific attribute values and
binding attributes to variables.</p>
<h3 id="complex-pattern-matching-examples">Complex Pattern Matching
Examples</h3>
<h4 id="recursive-pattern-matching">Recursive Pattern Matching</h4>
<p>Pattern matching excels at handling recursive data structures:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sum_list_2(lst: MyBaseList[<span class="bu">int</span>]) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> lst:</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="va">None</span>:</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> MyList(head<span class="op">=</span>x, tail<span class="op">=</span>y):</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x <span class="op">+</span> sum_list_2(y)</span></code></pre></div>
<p>This function processes a custom linked list structure using pattern
matching to handle the base case (None) and recursive case
elegantly.</p>
<h4 id="parsing-expressions">Parsing Expressions</h4>
<p>Pattern matching can implement simple interpreters:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> eval_expr(expr: Expr) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> expr:</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="bu">int</span>(x):</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Sum(left<span class="op">=</span>x, right<span class="op">=</span>y):</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> eval_expr(x) <span class="op">+</span> eval_expr(y)</span></code></pre></div>
<p>This code evaluates a simple arithmetic expression tree, showing how
pattern matching simplifies traversal of complex structures.</p>
<h2 id="section-3-combining-types-and-pattern-matching">Section 3:
Combining Types and Pattern Matching</h2>
<h3 id="algebraic-data-types-in-python">Algebraic Data Types in
Python</h3>
<p>Python can implement algebraic data types (ADTs) using classes,
dataclasses, and union types:</p>
<h4 id="sum-types-tagged-unions">Sum Types (Tagged Unions)</h4>
<p>Sum types represent values that could be one of several
alternatives:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Human:</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    drivingLicense: Literal[<span class="va">True</span>, <span class="va">False</span>]</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Dog:</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    kind: DogKind</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    colour: Literal[<span class="st">&quot;brown&quot;</span>, <span class="st">&quot;black&quot;</span>, <span class="st">&quot;white&quot;</span>]</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> Record <span class="op">=</span> Human <span class="op">|</span> Dog</span></code></pre></div>
<p>This example defines two distinct record types (<code>Human</code>
and <code>Dog</code>) and a union type <code>Record</code> that can be
either of them.</p>
<h4 id="pattern-matching-with-sum-types">Pattern Matching with Sum
Types</h4>
<p>Pattern matching works seamlessly with sum types:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> describe_person(person: Human <span class="op">|</span> Dog) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> person:</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Human(name<span class="op">=</span>name, drivingLicense<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ss">f&quot;Person </span><span class="sc">{</span>name<span class="sc">}</span><span class="ss"> has a driving license&quot;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Human(name<span class="op">=</span>name, drivingLicense<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ss">f&quot;Person </span><span class="sc">{</span>name<span class="sc">}</span><span class="ss"> does not have a driving license&quot;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Dog(name<span class="op">=</span>name, kind<span class="op">=</span>kind, colour<span class="op">=</span>colour):</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ss">f&quot;Dog </span><span class="sc">{</span>name<span class="sc">}</span><span class="ss"> is a </span><span class="sc">{</span>kind<span class="sc">}</span><span class="ss"> and has a </span><span class="sc">{</span>colour<span class="sc">}</span><span class="ss"> colour&quot;</span></span></code></pre></div>
<p>This function handles different record types with specific patterns
for each case.</p>
<h4 id="product-types">Product Types</h4>
<p>Product types represent combinations of values:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Person:</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    age: <span class="bu">int</span></span></code></pre></div>
<p>A dataclass like <code>Person</code> is a product type, representing
a combination of a string and an integer.</p>
<h3 id="type-checking-and-pattern-matching">Type Checking and Pattern
Matching</h3>
<p>Type checkers like mypy can catch errors in pattern matching
code:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> describe_person_2(person: Record) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(person, Human):</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> person.name <span class="op">+</span> person.colour  <span class="co"># Type error: Human has no attribute &#39;colour&#39;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> person.name <span class="op">+</span> person.kind</span></code></pre></div>
<p>Type checking helps identify incorrect attribute access, which might
otherwise lead to runtime errors.</p>
<h2 id="section-4-applications-and-best-practices">Section 4:
Applications and Best Practices</h2>
<h3 id="when-to-use-type-annotations">When to Use Type Annotations</h3>
<p>Type annotations are particularly valuable in: - Large codebases with
multiple developers - APIs and libraries that will be used by others -
Performance-critical code where type-specific optimizations matter -
Complex data processing pipelines</p>
<p><strong>Domain-specific languages, interpreters, ADTs!!</strong></p>
<h3 id="when-to-use-pattern-matching">When to Use Pattern Matching</h3>
<p>Pattern matching excels at: - Processing complex recursive data
structures - Implementing interpreters and compilers - Handling
case-based logic with destructuring - Processing structured data like
JSON or ASTs</p>
<h3 id="best-practices-for-type-annotations">Best Practices for Type
Annotations</h3>
<ol type="1">
<li>Be consistent with type annotations across your codebase</li>
<li>Use type aliases for complex or repetitive type expressions</li>
<li>Leverage tools like mypy, pyright, or pylance for static type
checking</li>
<li>Balance between type precision and code readability</li>
<li>Document non-obvious type constraints with comments</li>
</ol>
<h3 id="best-practices-for-pattern-matching">Best Practices for Pattern
Matching</h3>
<ol type="1">
<li>Order cases from most specific to most general</li>
<li>Use the wildcard pattern (<code>_</code>) as the last case</li>
<li>Consider using guard clauses for complex conditions</li>
<li>Break complex pattern matching into smaller functions</li>
<li>Leverage destructuring to avoid redundant variable assignments</li>
</ol>
<h2 id="exercises">Exercises</h2>
<ul>
<li><p>Consider the expression evaluator written in Lecture 01. Turn it
into a parser that converts a string of the form “x op y op z …”
separated by spaces into an AST in the sense of Lecture 02. Concatenate
the new parser and the evaluation function that takes AST as input to
define a mini-interpreter.</p></li>
<li><p>Add the “==” boolean operator to the AST and the
evaluator.</p></li>
</ul>
<h2 id="additional-resources">Additional Resources</h2>
<ul>
<li><a href="https://peps.python.org/pep-0484/">PEP 484 – Type
Hints</a></li>
<li><a href="https://peps.python.org/pep-0585/">PEP 585 – Type Hinting
Generics In Standard Collections</a></li>
<li><a href="https://peps.python.org/pep-0604/">PEP 604 – Allow writing
union types as X | Y</a></li>
<li><a href="https://peps.python.org/pep-0634/">PEP 634 – Structural
Pattern Matching: Specification</a></li>
<li><a href="https://peps.python.org/pep-0636/">PEP 636 – Structural
Pattern Matching: Tutorial</a></li>
<li><a href="https://mypy.readthedocs.io/en/stable/">Mypy Type Checker
Documentation</a></li>
<li><a href="https://realpython.com/python-type-checking/">Real Python:
Python Type Checking</a></li>
<li><a href="https://realpython.com/python-pattern-matching/">Real
Python: Structural Pattern Matching in Python</a></li>
</ul>
<h1 id="chapter-3-building-a-mini-interpreter">Chapter 3: Building a
Mini Interpreter</h1>
<h2 id="section-1-introduction-to-interpreters">Section 1: Introduction
to Interpreters</h2>
<p>An interpreter is a program that executes source code directly,
without requiring compilation to machine code. Let’s explore how
interpreters work and how to build a simple one in Python.</p>
<h3 id="the-role-of-interpreters">The Role of Interpreters</h3>
<p>Interpreters serve several important purposes in programming language
implementation:</p>
<ol type="1">
<li><strong>Direct Execution</strong>: Execute source code without a
separate compilation step</li>
<li><strong>Immediate Feedback</strong>: Provide instant results for
interactive programming</li>
<li><strong>Portability</strong>: Run on any platform that supports the
interpreter</li>
<li><strong>Simplicity</strong>: Often easier to implement than full
compilers</li>
<li><strong>Debugging</strong>: Allow for interactive debugging and
inspection</li>
</ol>
<p>Languages like Python, JavaScript, and Ruby primarily use
interpreters, while others like Java use a hybrid approach with
compilation to bytecode followed by interpretation.</p>
<h3 id="components-of-an-interpreter">Components of an Interpreter</h3>
<p>A typical interpreter includes the following components:</p>
<ol type="1">
<li><strong>Lexer (Tokenizer)</strong>: Converts source code text into
tokens</li>
<li><strong>Parser</strong>: Transforms tokens into an abstract syntax
tree (AST)</li>
<li><strong>Evaluator</strong>: Executes the AST to produce results</li>
<li><strong>Environment</strong>: Stores variables and their values</li>
<li><strong>Error Handler</strong>: Manages and reports errors</li>
</ol>
<p>We’ll implement each of these components in our mini interpreter.</p>
<h2 id="section-2-lexical-analysis">Section 2: Lexical Analysis</h2>
<p>The first step in interpreting code is breaking it down into tokens -
the smallest meaningful units in the language.</p>
<h3 id="tokens-and-lexical-structure">Tokens and Lexical Structure</h3>
<p>Tokens are the building blocks of a language, similar to words in
natural language. Common token types include:</p>
<ul>
<li><strong>Keywords</strong>: Reserved words with special meaning
(e.g., <code>if</code>, <code>while</code>)</li>
<li><strong>Identifiers</strong>: Names given to variables, functions,
etc.</li>
<li><strong>Literals</strong>: Constant values (numbers, strings,
booleans)</li>
<li><strong>Operators</strong>: Symbols that perform operations
(<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>)</li>
<li><strong>Punctuation</strong>: Symbols that structure the code
(<code>;</code>, <code>,</code>, <code>{}</code>, <code>()</code>)</li>
</ul>
<h3 id="implementing-a-lexer">Implementing a Lexer</h3>
<p>Our lexer will convert a string of source code into a list of
tokens:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dataclasses <span class="im">import</span> dataclass</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> enum <span class="im">import</span> Enum, auto</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> List, Optional</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define token types</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TokenType(Enum):</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    NUMBER <span class="op">=</span> auto()</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    PLUS <span class="op">=</span> auto()</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    MINUS <span class="op">=</span> auto()</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    MULTIPLY <span class="op">=</span> auto()</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    DIVIDE <span class="op">=</span> auto()</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    LPAREN <span class="op">=</span> auto()</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    RPAREN <span class="op">=</span> auto()</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    EOF <span class="op">=</span> auto()  <span class="co"># End of file</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Token:</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">type</span>: TokenType</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    value: Optional[<span class="bu">str</span>] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tokenize(text: <span class="bu">str</span>) <span class="op">-&gt;</span> List[Token]:</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    tokens <span class="op">=</span> []</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(text):</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>        char <span class="op">=</span> text[i]</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Skip whitespace</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> char.isspace():</span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Process numbers</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> char.isdigit():</span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>            num <span class="op">=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(text) <span class="kw">and</span> text[i].isdigit():</span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>                num <span class="op">+=</span> text[i]</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>                i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>            tokens.append(Token(TokenType.NUMBER, num))</span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Process operators</span></span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> char <span class="op">==</span> <span class="st">&#39;+&#39;</span>:</span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a>            tokens.append(Token(TokenType.PLUS))</span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> char <span class="op">==</span> <span class="st">&#39;-&#39;</span>:</span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a>            tokens.append(Token(TokenType.MINUS))</span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> char <span class="op">==</span> <span class="st">&#39;*&#39;</span>:</span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a>            tokens.append(Token(TokenType.MULTIPLY))</span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> char <span class="op">==</span> <span class="st">&#39;/&#39;</span>:</span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a>            tokens.append(Token(TokenType.DIVIDE))</span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> char <span class="op">==</span> <span class="st">&#39;(&#39;</span>:</span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>            tokens.append(Token(TokenType.LPAREN))</span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> char <span class="op">==</span> <span class="st">&#39;)&#39;</span>:</span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a>            tokens.append(Token(TokenType.RPAREN))</span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb25-56"><a href="#cb25-56" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Unexpected character: </span><span class="sc">{</span>char<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb25-57"><a href="#cb25-57" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb25-58"><a href="#cb25-58" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-59"><a href="#cb25-59" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-60"><a href="#cb25-60" aria-hidden="true" tabindex="-1"></a>    tokens.append(Token(TokenType.EOF))</span>
<span id="cb25-61"><a href="#cb25-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tokens</span></code></pre></div>
<h3 id="testing-the-lexer">Testing the Lexer</h3>
<p>Let’s test our lexer with a simple arithmetic expression:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_lexer():</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    source <span class="op">=</span> <span class="st">&quot;3 + 4 * (2 - 1)&quot;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    tokens <span class="op">=</span> tokenize(source)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    expected <span class="op">=</span> [</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        Token(TokenType.NUMBER, <span class="st">&quot;3&quot;</span>),</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>        Token(TokenType.PLUS),</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>        Token(TokenType.NUMBER, <span class="st">&quot;4&quot;</span>),</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>        Token(TokenType.MULTIPLY),</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>        Token(TokenType.LPAREN),</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>        Token(TokenType.NUMBER, <span class="st">&quot;2&quot;</span>),</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>        Token(TokenType.MINUS),</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>        Token(TokenType.NUMBER, <span class="st">&quot;1&quot;</span>),</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>        Token(TokenType.RPAREN),</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>        Token(TokenType.EOF)</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> tokens <span class="op">==</span> expected, <span class="ss">f&quot;Expected </span><span class="sc">{</span>expected<span class="sc">}</span><span class="ss">, got </span><span class="sc">{</span>tokens<span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Lexer test passed!&quot;</span>)</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>test_lexer()</span></code></pre></div>
<h2 id="section-3-parsing-and-abstract-syntax-trees">Section 3: Parsing
and Abstract Syntax Trees</h2>
<p>Once we have tokens, we need to organize them into a structured
representation of the program - an Abstract Syntax Tree (AST).</p>
<h3 id="understanding-abstract-syntax-trees">Understanding Abstract
Syntax Trees</h3>
<p>An AST is a tree representation of the abstract syntactic structure
of source code. Each node in the tree represents a construct in the
source code.</p>
<p>For example, the expression <code>3 + 4 * 2</code> would be
represented as:</p>
<pre><code>    (+)
   /   \
  3    (*)
      /   \
     4     2</code></pre>
<p>The tree captures the structure and precedence of operations.</p>
<h3 id="defining-ast-nodes">Defining AST Nodes</h3>
<p>Let’s define classes for our AST nodes:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dataclasses <span class="im">import</span> dataclass</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Union, Optional</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Number:</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    value: <span class="bu">float</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BinaryOp:</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    left: <span class="st">&#39;Expression&#39;</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    operator: <span class="bu">str</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    right: <span class="st">&#39;Expression&#39;</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Define our Expression type</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>Expression <span class="op">=</span> Union[Number, BinaryOp]</span></code></pre></div>
<h3 id="implementing-a-recursive-descent-parser">Implementing a
Recursive Descent Parser</h3>
<p>A recursive descent parser is a top-down parser that uses a set of
recursive procedures to process the input:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Parser:</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, tokens: List[Token]):</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.tokens <span class="op">=</span> tokens</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.current <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> peek(<span class="va">self</span>) <span class="op">-&gt;</span> Token:</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.tokens[<span class="va">self</span>.current]</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> previous(<span class="va">self</span>) <span class="op">-&gt;</span> Token:</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.tokens[<span class="va">self</span>.current <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> advance(<span class="va">self</span>) <span class="op">-&gt;</span> Token:</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.is_at_end():</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.current <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.previous()</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> is_at_end(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.peek().<span class="bu">type</span> <span class="op">==</span> TokenType.EOF</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> check(<span class="va">self</span>, <span class="bu">type</span>: TokenType) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.is_at_end():</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.peek().<span class="bu">type</span> <span class="op">==</span> <span class="bu">type</span></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> match(<span class="va">self</span>, <span class="op">*</span>types: TokenType) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="bu">type</span> <span class="kw">in</span> types:</span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.check(<span class="bu">type</span>):</span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.advance()</span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> consume(<span class="va">self</span>, <span class="bu">type</span>: TokenType, message: <span class="bu">str</span>) <span class="op">-&gt;</span> Token:</span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.check(<span class="bu">type</span>):</span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.advance()</span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">Exception</span>(message)</span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parse(<span class="va">self</span>) <span class="op">-&gt;</span> Expression:</span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.expression()</span>
<span id="cb29-39"><a href="#cb29-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-40"><a href="#cb29-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> expression(<span class="va">self</span>) <span class="op">-&gt;</span> Expression:</span>
<span id="cb29-41"><a href="#cb29-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.term()</span>
<span id="cb29-42"><a href="#cb29-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-43"><a href="#cb29-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> term(<span class="va">self</span>) <span class="op">-&gt;</span> Expression:</span>
<span id="cb29-44"><a href="#cb29-44" aria-hidden="true" tabindex="-1"></a>        expr <span class="op">=</span> <span class="va">self</span>.factor()</span>
<span id="cb29-45"><a href="#cb29-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb29-46"><a href="#cb29-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">self</span>.match(TokenType.PLUS, TokenType.MINUS):</span>
<span id="cb29-47"><a href="#cb29-47" aria-hidden="true" tabindex="-1"></a>            operator <span class="op">=</span> <span class="va">self</span>.previous().<span class="bu">type</span></span>
<span id="cb29-48"><a href="#cb29-48" aria-hidden="true" tabindex="-1"></a>            right <span class="op">=</span> <span class="va">self</span>.factor()</span>
<span id="cb29-49"><a href="#cb29-49" aria-hidden="true" tabindex="-1"></a>            expr <span class="op">=</span> BinaryOp(</span>
<span id="cb29-50"><a href="#cb29-50" aria-hidden="true" tabindex="-1"></a>                expr, </span>
<span id="cb29-51"><a href="#cb29-51" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;+&quot;</span> <span class="cf">if</span> operator <span class="op">==</span> TokenType.PLUS <span class="cf">else</span> <span class="st">&quot;-&quot;</span>, </span>
<span id="cb29-52"><a href="#cb29-52" aria-hidden="true" tabindex="-1"></a>                right</span>
<span id="cb29-53"><a href="#cb29-53" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb29-54"><a href="#cb29-54" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb29-55"><a href="#cb29-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> expr</span>
<span id="cb29-56"><a href="#cb29-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-57"><a href="#cb29-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> factor(<span class="va">self</span>) <span class="op">-&gt;</span> Expression:</span>
<span id="cb29-58"><a href="#cb29-58" aria-hidden="true" tabindex="-1"></a>        expr <span class="op">=</span> <span class="va">self</span>.primary()</span>
<span id="cb29-59"><a href="#cb29-59" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb29-60"><a href="#cb29-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">self</span>.match(TokenType.MULTIPLY, TokenType.DIVIDE):</span>
<span id="cb29-61"><a href="#cb29-61" aria-hidden="true" tabindex="-1"></a>            operator <span class="op">=</span> <span class="va">self</span>.previous().<span class="bu">type</span></span>
<span id="cb29-62"><a href="#cb29-62" aria-hidden="true" tabindex="-1"></a>            right <span class="op">=</span> <span class="va">self</span>.primary()</span>
<span id="cb29-63"><a href="#cb29-63" aria-hidden="true" tabindex="-1"></a>            expr <span class="op">=</span> BinaryOp(</span>
<span id="cb29-64"><a href="#cb29-64" aria-hidden="true" tabindex="-1"></a>                expr, </span>
<span id="cb29-65"><a href="#cb29-65" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;*&quot;</span> <span class="cf">if</span> operator <span class="op">==</span> TokenType.MULTIPLY <span class="cf">else</span> <span class="st">&quot;/&quot;</span>, </span>
<span id="cb29-66"><a href="#cb29-66" aria-hidden="true" tabindex="-1"></a>                right</span>
<span id="cb29-67"><a href="#cb29-67" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb29-68"><a href="#cb29-68" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb29-69"><a href="#cb29-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> expr</span>
<span id="cb29-70"><a href="#cb29-70" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-71"><a href="#cb29-71" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> primary(<span class="va">self</span>) <span class="op">-&gt;</span> Expression:</span>
<span id="cb29-72"><a href="#cb29-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.match(TokenType.NUMBER):</span>
<span id="cb29-73"><a href="#cb29-73" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Number(<span class="bu">float</span>(<span class="va">self</span>.previous().value))</span>
<span id="cb29-74"><a href="#cb29-74" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb29-75"><a href="#cb29-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.match(TokenType.LPAREN):</span>
<span id="cb29-76"><a href="#cb29-76" aria-hidden="true" tabindex="-1"></a>            expr <span class="op">=</span> <span class="va">self</span>.expression()</span>
<span id="cb29-77"><a href="#cb29-77" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.consume(TokenType.RPAREN, <span class="st">&quot;Expect &#39;)&#39; after expression.&quot;</span>)</span>
<span id="cb29-78"><a href="#cb29-78" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> expr</span>
<span id="cb29-79"><a href="#cb29-79" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb29-80"><a href="#cb29-80" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="ss">f&quot;Unexpected token: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>peek()<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<p>This parser implements the following grammar:</p>
<pre><code>expression → term
term       → factor ((&quot;+&quot;|&quot;-&quot;) factor)*
factor     → primary ((&quot;*&quot;|&quot;/&quot;) primary)*
primary    → NUMBER | &quot;(&quot; expression &quot;)&quot;</code></pre>
<h3 id="testing-the-parser">Testing the Parser</h3>
<p>Let’s test our parser with the same expression:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_parser():</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    tokens <span class="op">=</span> tokenize(<span class="st">&quot;3 + 4 * 2&quot;</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    parser <span class="op">=</span> Parser(tokens)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    ast <span class="op">=</span> parser.parse()</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Expected: BinaryOp(Number(3), &quot;+&quot;, BinaryOp(Number(4), &quot;*&quot;, Number(2)))</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    expected <span class="op">=</span> BinaryOp(</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>        Number(<span class="dv">3</span>),</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;+&quot;</span>,</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>        BinaryOp(</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>            Number(<span class="dv">4</span>),</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;*&quot;</span>,</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>            Number(<span class="dv">2</span>)</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> ast <span class="op">==</span> expected, <span class="ss">f&quot;Expected </span><span class="sc">{</span>expected<span class="sc">}</span><span class="ss">, got </span><span class="sc">{</span>ast<span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Parser test passed!&quot;</span>)</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>test_parser()</span></code></pre></div>
<h2 id="section-4-evaluating-expressions">Section 4: Evaluating
Expressions</h2>
<p>Now that we have an AST, we can evaluate it to produce a result.</p>
<h3 id="the-evaluation-process">The Evaluation Process</h3>
<p>Evaluation is the process of computing the result of an expression.
It typically involves:</p>
<ol type="1">
<li>Walking the AST recursively</li>
<li>Computing the value of each node based on its type and children</li>
<li>Combining results according to the language semantics</li>
</ol>
<h3 id="implementing-an-evaluator-1">Implementing an Evaluator</h3>
<p>For our mini interpreter, we’ll implement a simple evaluator that
computes arithmetic expressions:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate(expr: Expression) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Evaluate an expression and return its value.&quot;&quot;&quot;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> expr:</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Number(value):</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> value</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> BinaryOp(left, operator, right):</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>            left_value <span class="op">=</span> evaluate(left)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>            right_value <span class="op">=</span> evaluate(right)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> operator:</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">case</span> <span class="st">&quot;+&quot;</span>:</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> left_value <span class="op">+</span> right_value</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">case</span> <span class="st">&quot;-&quot;</span>:</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> left_value <span class="op">-</span> right_value</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">case</span> <span class="st">&quot;*&quot;</span>:</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> left_value <span class="op">*</span> right_value</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">case</span> <span class="st">&quot;/&quot;</span>:</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> right_value <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">raise</span> <span class="pp">ZeroDivisionError</span>(<span class="st">&quot;Division by zero&quot;</span>)</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> left_value <span class="op">/</span> right_value</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">case</span> _:</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Unknown operator: </span><span class="sc">{</span>operator<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="testing-the-evaluator">Testing the Evaluator</h3>
<p>Let’s test our evaluator with a few expressions:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_evaluator():</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    expressions <span class="op">=</span> [</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;3 + 4&quot;</span>, <span class="dv">7</span>),</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;3 * 4&quot;</span>, <span class="dv">12</span>),</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;10 - 2&quot;</span>, <span class="dv">8</span>),</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;20 / 5&quot;</span>, <span class="dv">4</span>),</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;3 + 4 * 2&quot;</span>, <span class="dv">11</span>),  <span class="co"># Tests operator precedence</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;(3 + 4) * 2&quot;</span>, <span class="dv">14</span>),  <span class="co"># Tests parentheses</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> source, expected <span class="kw">in</span> expressions:</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>        tokens <span class="op">=</span> tokenize(source)</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>        parser <span class="op">=</span> Parser(tokens)</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>        ast <span class="op">=</span> parser.parse()</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> evaluate(ast)</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> result <span class="op">==</span> expected, <span class="ss">f&quot;For &#39;</span><span class="sc">{</span>source<span class="sc">}</span><span class="ss">&#39;, expected </span><span class="sc">{</span>expected<span class="sc">}</span><span class="ss">, got </span><span class="sc">{</span>result<span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Evaluator tests passed!&quot;</span>)</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>test_evaluator()</span></code></pre></div>
<h2 id="section-5-putting-it-all-together">Section 5: Putting It All
Together</h2>
<p>Now we’ll combine our lexer, parser, and evaluator into a complete
mini interpreter.</p>
<h3 id="the-full-interpreter">The Full Interpreter</h3>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> interpret(source: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Interpret a source string and return the result.&quot;&quot;&quot;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>        tokens <span class="op">=</span> tokenize(source)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        parser <span class="op">=</span> Parser(tokens)</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        ast <span class="op">=</span> parser.parse()</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> evaluate(ast)</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;Error: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">float</span>(<span class="st">&#39;nan&#39;</span>)  <span class="co"># Return NaN for errors</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_repl():</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Run a simple Read-Eval-Print Loop.&quot;&quot;&quot;</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Mini Interpreter REPL&quot;</span>)</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Enter expressions to evaluate, or &#39;exit&#39; to quit&quot;</span>)</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>            source <span class="op">=</span> <span class="bu">input</span>(<span class="st">&quot;&gt; &quot;</span>)</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> source.lower() <span class="kw">in</span> (<span class="st">&quot;exit&quot;</span>, <span class="st">&quot;quit&quot;</span>):</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> interpret(source)</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;= </span><span class="sc">{</span>result<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">KeyboardInterrupt</span>:</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;Error: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Goodbye!&quot;</span>)</span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>    run_repl()</span></code></pre></div>
<h3 id="example-usage">Example Usage</h3>
<p>Using our interpreter:</p>
<pre><code>Mini Interpreter REPL
Enter expressions to evaluate, or &#39;exit&#39; to quit
&gt; 3 + 4
= 7.0
&gt; 3 * (4 + 2)
= 18.0
&gt; 10 / (2 - 2)
Error: Division by zero
&gt; (3 + 4) * (5 - 2)
= 21.0
&gt; exit
Goodbye!</code></pre>
<h2 id="section-6-extending-the-interpreter">Section 6: Extending the
Interpreter</h2>
<p>Our mini interpreter is very basic, but we can extend it with more
features.</p>
<h3 id="adding-variables">Adding Variables</h3>
<p>To add variable support, we need:</p>
<ol type="1">
<li>An environment to store variable bindings</li>
<li>New AST nodes for variable references and assignments</li>
<li>Updated parsing rules</li>
<li>Updated evaluation logic</li>
</ol>
<p>Let’s implement a simple environment first:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Environment:</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    values: <span class="bu">dict</span>[<span class="bu">str</span>, <span class="bu">float</span>] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> __post_init__(<span class="va">self</span>):</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.values <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.values <span class="op">=</span> {}</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> define(<span class="va">self</span>, name: <span class="bu">str</span>, value: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Define a variable with the given name and value.&quot;&quot;&quot;</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.values[name] <span class="op">=</span> value</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get(<span class="va">self</span>, name: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Get the value of a variable.&quot;&quot;&quot;</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> name <span class="kw">in</span> <span class="va">self</span>.values:</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.values[name]</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Undefined variable: </span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="new-ast-nodes-for-variables">New AST Nodes for Variables</h3>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Variable:</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Assignment:</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    value: <span class="st">&#39;Expression&#39;</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Update Expression type</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>Expression <span class="op">=</span> Union[Number, BinaryOp, Variable, Assignment]</span></code></pre></div>
<h3 id="updating-the-parser">Updating the Parser</h3>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Parser:</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... existing code ...</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parse(<span class="va">self</span>) <span class="op">-&gt;</span> Expression:</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.assignment()</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> assignment(<span class="va">self</span>) <span class="op">-&gt;</span> Expression:</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>        expr <span class="op">=</span> <span class="va">self</span>.expression()</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.match(TokenType.EQUAL):</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">isinstance</span>(expr, Variable):</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>                value <span class="op">=</span> <span class="va">self</span>.assignment()</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> Assignment(expr.name, value)</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&quot;Invalid assignment target&quot;</span>)</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> expr</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... update tokenize() to handle identifiers and &#39;=&#39; ...</span></span></code></pre></div>
<h3 id="updating-the-evaluator">Updating the Evaluator</h3>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate(expr: Expression, env: Environment) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Evaluate an expression in the given environment.&quot;&quot;&quot;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> expr:</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Number(value):</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> value</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Variable(name):</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> env.get(name)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Assignment(name, value):</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> evaluate(value, env)</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>            env.define(name, result)</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> result</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> BinaryOp(left, operator, right):</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>            <span class="co"># ... existing code ...</span></span></code></pre></div>
<h3 id="adding-control-flow">Adding Control Flow</h3>
<p>We can extend our language with if-expressions:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> If:</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    condition: Expression</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    then_branch: Expression</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    else_branch: Expression</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Update Expression type</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>Expression <span class="op">=</span> Union[Number, BinaryOp, Variable, Assignment, If]</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Update evaluator</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate(expr: Expression, env: Environment) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> expr:</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... existing cases ...</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> If(condition, then_branch, else_branch):</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> evaluate(condition, env) <span class="op">!=</span> <span class="dv">0</span>:  <span class="co"># Non-zero is true</span></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> evaluate(then_branch, env)</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> evaluate(else_branch, env)</span></code></pre></div>
<h2 id="section-7-further-exploration">Section 7: Further
Exploration</h2>
<p>Here are some ways you could extend our mini interpreter further:</p>
<h3 id="additional-features-to-implement">Additional Features to
Implement</h3>
<ol type="1">
<li><strong>Functions</strong>: Add function declarations and calls</li>
<li><strong>Loops</strong>: Implement while or for loops</li>
<li><strong>More Operators</strong>: Add comparison, logical, and
bitwise operators</li>
<li><strong>Error Handling</strong>: Improve error messages and
recovery</li>
<li><strong>Type System</strong>: Add a simple type system</li>
<li><strong>Standard Library</strong>: Implement built-in functions for
common operations</li>
</ol>
<h3 id="learning-resources">Learning Resources</h3>
<p>To learn more about interpreters and language implementation:</p>
<ul>
<li><strong>“Crafting Interpreters”</strong> by Robert Nystrom: A
comprehensive guide to implementing interpreters</li>
<li><strong>“Programming Language Pragmatics”</strong> by Michael Scott:
Covers theoretical aspects of language design</li>
<li><strong>“Structure and Interpretation of Computer Programs”</strong>
by Abelson and Sussman: A classic text on programming language
concepts</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Building a mini interpreter helps understand how programming
languages work under the hood. We’ve seen how to:</p>
<ol type="1">
<li>Tokenize source code into lexical tokens</li>
<li>Parse tokens into an abstract syntax tree</li>
<li>Evaluate the AST to produce results</li>
<li>Extend the interpreter with new features</li>
</ol>
<p>This foundation can be expanded to build more complex languages and
tools.</p>
<h1 id="chapter-4-semantic-domains-and-environment-based-interpreters">Chapter
4: Semantic Domains and Environment-Based Interpreters</h1>
<h2 id="section-1-introduction-to-semantic-domains">Section 1:
Introduction to Semantic Domains</h2>
<p>In programming language semantics, <strong>semantic domains</strong>
are mathematical structures used to give meaning to syntactic
constructs. They provide the foundation for defining the behavior of
programs in a precise, mathematical way.</p>
<h3 id="key-semantic-domains-in-programming-languages">Key Semantic
Domains in Programming Languages</h3>
<ul>
<li><strong>Syntactic Domains</strong>: Represent the structure of
programs (tokens, parse trees, syntax trees).</li>
<li><strong>Semantic Domains</strong>: Represent the meaning of programs
(values, environments, states).</li>
</ul>
<p>The relationship between these domains is at the heart of language
semantics:</p>
<pre><code>Syntax -&gt; Semantics
Program -&gt; Meaning</code></pre>
<h3 id="core-semantic-domains">Core Semantic Domains</h3>
<p>In our mini-interpreter, we’ll work with several fundamental semantic
domains:</p>
<ul>
<li><strong>Expressible Values</strong>: Values that can be produced by
evaluating expressions</li>
<li><strong>Denotable Values (DVal)</strong>: Values that can be bound
to identifiers in the environment</li>
<li><strong>Memorizable Values (MVal)</strong>: Values that can be
stored in memory/state</li>
<li><strong>Identifiers</strong>: Names of constants, variables,
functions, modules, etc.</li>
<li><strong>Locations</strong>: Memory addresses of variables</li>
<li><strong>Environment</strong>: Maps identifiers to denotable values,
representing the binding context</li>
<li><strong>State</strong>: Maps memory locations to memorizable values,
representing the program’s memory</li>
</ul>
<p>While these domains often overlap, they aren’t necessarily identical.
Understanding the differences is crucial for language design.</p>
<h3 id="side-effects-and-pure-functions">Side Effects and Pure
Functions</h3>
<p>A fundamental distinction in programming language semantics is
between <strong>pure</strong> computations and those that produce
<strong>side effects</strong>.</p>
<h4 id="pure-functions">Pure Functions</h4>
<p>A <strong>pure function</strong> is a computation that: 1. Always
produces the same output for the same input 2. Has no observable effects
beyond computing its result</p>
<p>In mathematical terms, a pure function is simply a mapping from
inputs to outputs, like mathematical functions (e.g., sin(x),
log(x)).</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add(x: <span class="bu">int</span>, y: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> y  <span class="co"># Pure: same inputs always give same output</span></span></code></pre></div>
<h4 id="side-effects">Side Effects</h4>
<p>A <strong>side effect</strong> is any observable change to the system
state that occurs during computation, beyond returning a value. Common
side effects include:</p>
<ol type="1">
<li><p><strong>Memory updates</strong>: Modifying variables or data
structures</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">10</span>  <span class="co"># Changes the program&#39;s state</span></span></code></pre></div>
<p>Q: in this context, what is a function that does <strong>not</strong>
return always the same value for the same inputs?</p></li>
<li><p><strong>Input/Output operations</strong>:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Hello&quot;</span>)  <span class="co"># Affects the external world (terminal)</span></span></code></pre></div></li>
<li><p><strong>File operations</strong>:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">&quot;data.txt&quot;</span>, <span class="st">&quot;w&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    f.write(<span class="st">&quot;data&quot;</span>)  <span class="co"># Changes the file system</span></span></code></pre></div></li>
<li><p><strong>Network operations</strong>:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>requests.get(<span class="st">&quot;https://example.com&quot;</span>)  <span class="co"># Interacts with external systems</span></span></code></pre></div></li>
</ol>
<h4 id="memory-updates-as-side-effects">Memory Updates as Side
Effects</h4>
<p>In our interpreter design, memory (state) updates are a primary form
of side effect. When we update state:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> state_update(state: State, location: <span class="bu">int</span>, value: MVal) <span class="op">-&gt;</span> State:</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    new_state <span class="op">=</span> state.copy() </span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    new_state[location] <span class="op">=</span> value</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_state</span></code></pre></div>
<p>We’re representing a change to the program’s memory. In a real
computer, this would modify memory cells directly. Our functional
implementation returns a new state rather than modifying the existing
one, but conceptually it represents the same side effect.</p>
<h4 id="side-effects-in-programming-languages">Side Effects in
Programming Languages</h4>
<p>Languages differ in how they handle side effects:</p>
<ul>
<li><strong>Purely functional languages</strong> (like Haskell) isolate
side effects using type systems and monads</li>
<li><strong>Imperative languages</strong> (like C, Python) embrace side
effects as their primary mechanism for computation</li>
<li><strong>Hybrid languages</strong> (like Scala, OCaml) support both
styles</li>
</ul>
<p>Understanding side effects is crucial for language design because
they impact: - Program correctness (pure functions are easier to reason
about) - Parallelization (side effects complicate parallel execution) -
Optimization (pure functions allow more aggressive optimizations)</p>
<p>In our interpreter, we’ll model side effects using explicit state
passing, maintaining the mathematical clarity of our semantics while
accurately representing the behavior of stateful programs.</p>
<h2 id="section-2-denotable-vs.-memorizable-values">Section 2: Denotable
vs. Memorizable Values</h2>
<h3 id="denotable-values-dval">Denotable Values (DVal)</h3>
<p>Denotable values are those that can be bound to identifiers in an
environment. In our implementation, they include:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> Num <span class="op">=</span> <span class="bu">int</span>  <span class="co"># A type alias for integers</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> DenOperator <span class="op">=</span> Callable[[<span class="bu">int</span>, <span class="bu">int</span>], <span class="bu">int</span>]</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> DVal <span class="op">=</span> <span class="bu">int</span> <span class="op">|</span> DenOperator  <span class="co"># Denotable values</span></span></code></pre></div>
<p>DVal includes: - <strong>Numbers</strong>: Simple integer values -
<strong>Operators</strong>: Functions that take two integers and return
an integer</p>
<h3 id="memorizable-values-mval">Memorizable Values (MVal)</h3>
<p>Memorizable values are those that can be stored in memory (the
state). In our implementation:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> MVal <span class="op">=</span> <span class="bu">int</span>  <span class="co"># Memorizable values</span></span></code></pre></div>
<p>MVal only includes integers, not functions. This highlights an
important distinction:</p>
<blockquote>
<p>Not everything that can be bound to a name can be stored in
memory.</p>
</blockquote>
<p>This distinction is crucial for understanding: - Why some languages
don’t support first-class functions - Why some types require special
treatment in memory management - How languages with different type
systems handle values differently</p>
<h2 id="section-3-environment-and-state-as-functions">Section 3:
Environment and State as Functions</h2>
<p>In our treatment of semantic domains, we adopt a purely functional
approach where environments are represented as functions, and states are
represented as dataclasses containing store functions, rather than
mutable data structures. This approach aligns with the mathematical view
of semantic domains and provides a clean conceptual model for
understanding program behavior.</p>
<h3 id="functional-programming-a-brief-digression">Functional
Programming: A Brief Digression</h3>
<p>Before diving into our function-based implementation of environments
and state, it’s worth taking a brief detour to discuss functional
programming concepts, as they form the foundation of our approach.</p>
<p>Functional programming is a paradigm where computations are treated
as evaluations of mathematical functions, emphasizing immutable data and
avoiding side effects. Python, while not a pure functional language,
supports many functional programming techniques.</p>
<h4 id="functions-as-first-class-citizens">Functions as First-Class
Citizens</h4>
<p>In functional programming, functions are “first-class citizens” —
they can be: - Assigned to variables - Passed as arguments to other
functions - Returned from functions - Stored in data structures</p>
<p>For example:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function assigned to a variable</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>increment <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Function passed as an argument</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_twice(f, x):</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f(f(x))</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> apply_twice(increment, <span class="dv">3</span>)  <span class="co"># Returns 5</span></span></code></pre></div>
<h4 id="higher-order-functions-map">Higher-Order Functions: Map</h4>
<p>A common pattern in functional programming is applying a function to
each element in a collection. Python’s <code>map</code> function does
exactly this:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply a function to each element</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>squared <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="kw">lambda</span> x: x<span class="op">**</span><span class="dv">2</span>, numbers))  <span class="co"># [1, 4, 9, 16, 25]</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Equivalent to a list comprehension</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>squared_alt <span class="op">=</span> [x<span class="op">**</span><span class="dv">2</span> <span class="cf">for</span> x <span class="kw">in</span> numbers]  <span class="co"># [1, 4, 9, 16, 25]</span></span></code></pre></div>
<h4 id="function-composition">Function Composition</h4>
<p>Functional programming emphasizes building complex behaviors by
composing simpler functions:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compose(f, g):</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">lambda</span> x: f(g(x))</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Compose two functions</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>negate_and_square <span class="op">=</span> compose(<span class="kw">lambda</span> x: <span class="op">-</span>x, <span class="kw">lambda</span> x: x<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> negate_and_square(<span class="dv">5</span>)  <span class="co"># -25</span></span></code></pre></div>
<h4 id="pure-functions-and-immutability">Pure Functions and
Immutability</h4>
<p>Pure functions always produce the same output for the same input and
have no side effects. This property makes them predictable and easier to
reason about:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Pure function</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add(a, b):</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> b</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Impure function (has side effects)</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_and_print(a, b):</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> a <span class="op">+</span> b</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;The result is </span><span class="sc">{</span>result<span class="sc">}</span><span class="ss">&quot;</span>)  <span class="co"># Side effect: printing</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div>
<h4 id="relevance-to-semantic-domains">Relevance to Semantic
Domains</h4>
<p>These functional programming concepts directly inform our approach to
implementing semantic domains:</p>
<ol type="1">
<li>We represent environments and stores as functions, not data
structures</li>
<li>We use higher-order functions to create updated environments and
stores</li>
<li>We maintain immutability through functional updates rather than
mutations</li>
<li>We compose simple operations to build complex behaviors</li>
</ol>
<p>With this foundation in mind, let’s explore how we represent
environments and states as functions.</p>
<h3 id="environment-as-a-function">Environment as a Function</h3>
<p>An environment is mathematically a function that maps identifiers to
denotable values:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> Environment <span class="op">=</span> Callable[[<span class="bu">str</span>], DVal]</span></code></pre></div>
<p>This means an environment is a function that: - Takes an identifier
(string) as input - Returns a denotable value (DVal) - Raises an error
if the identifier is not defined</p>
<p>While many practical implementations use dictionaries or hash tables
for efficiency, conceptually an environment is simply a function:</p>
<pre><code>Environment: Identifier → DVal</code></pre>
<h3 id="state-as-a-dataclass">State as a Dataclass</h3>
<p>Unlike environment, which is purely a function, a state encapsulates
both a store function and allocation information:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> State:</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    store: Callable[[Location], MVal]  <span class="co"># The store function</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    next_loc: <span class="bu">int</span>                      <span class="co"># Next available location</span></span></code></pre></div>
<p>This represents a state as: - A dataclass containing a store function
and next location counter - The store function takes a location as input
and returns the value at that location - The next_loc field tracks the
next available memory location for allocation</p>
<p>Conceptually, the store component maintains the mapping:</p>
<pre><code>Store: Location → MVal</code></pre>
<p>While the next_loc component tracks allocation state.</p>
<h2 id="section-4-functional-updates">Section 4: Functional Updates</h2>
<p>In a purely functional approach, we don’t mutate existing
environments or states. Instead, we create new functions or dataclasses
that encapsulate the updated behavior.</p>
<h3 id="environment-updates">Environment Updates</h3>
<p>Instead of modifying a dictionary, we define a new function that
returns the new value for the updated identifier and delegates to the
original environment for all other identifiers:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bind(env: Environment, name: <span class="bu">str</span>, value: DVal) <span class="op">-&gt;</span> Environment:</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Create new environment with an added binding&quot;&quot;&quot;</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> new_env(n: <span class="bu">str</span>) <span class="op">-&gt;</span> DVal:</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">==</span> name:</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> value</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> env(n)</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_env</span></code></pre></div>
<p>This function returns a new environment that: - Returns
<code>value</code> when asked for <code>name</code> - Delegates to the
original environment for all other identifiers</p>
<p>This approach: - Preserves referential transparency - Enables easy
implementation of lexical scoping - Facilitates reasoning about program
behavior - Models the mathematical concept of function extension</p>
<h3 id="state-updates">State Updates</h3>
<p>Similarly, state updates create new State objects with updated store
functions:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> state_update(state: State, location: Location, value: MVal) <span class="op">-&gt;</span> State:</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Create new state with an updated value at given location&quot;&quot;&quot;</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> new_store(loc: Location) <span class="op">-&gt;</span> MVal:</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> loc <span class="op">==</span> location:</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> value</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> state.store(loc)</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> State(store<span class="op">=</span>new_store, next_loc<span class="op">=</span>state.next_loc)</span></code></pre></div>
<p>This function creates a new State object that: - Contains a new store
function that returns the new value when asked for the specified
location - Delegates to the original state’s store function for all
other locations - Preserves the next_loc value from the original
state</p>
<h3 id="empty-environment-and-state">Empty Environment and State</h3>
<p>The primitives for creating empty environments and states define
initial values:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> empty_environment() <span class="op">-&gt;</span> Environment:</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Create an empty environment function&quot;&quot;&quot;</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> env(name: <span class="bu">str</span>) <span class="op">-&gt;</span> DVal:</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Undefined identifier: </span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> env</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> empty_memory() <span class="op">-&gt;</span> State:</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Create an empty memory state&quot;&quot;&quot;</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> store(location: Location) <span class="op">-&gt;</span> MVal:</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Undefined memory location: </span><span class="sc">{</span>location<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> State(store<span class="op">=</span>store, next_loc<span class="op">=</span><span class="dv">0</span>)</span></code></pre></div>
<p>Note that empty_memory returns a State dataclass initialized with an
empty store function and next_loc set to 0.</p>
<h3 id="memory-allocation">Memory Allocation</h3>
<p>In a complete interpreter, we use the State dataclass to implement
memory allocation elegantly:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> allocate(state: State, value: MVal) <span class="op">-&gt;</span> <span class="bu">tuple</span>[State, Location]:</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Allocate a new memory location and store a value there.</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns the updated state and the new location.&quot;&quot;&quot;</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    location <span class="op">=</span> state.next_loc</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    new_state <span class="op">=</span> state_update(state, location, value)</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return state with incremented next_loc and the allocated location</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> State(store<span class="op">=</span>new_state.store, next_loc<span class="op">=</span>location <span class="op">+</span> <span class="dv">1</span>), location</span></code></pre></div>
<p>This function: 1. Gets the next available location from the state 2.
Updates the store function to map this location to the provided value 3.
Returns a new state with the incremented next_loc and the allocated
location</p>
<p>By bundling the store function with the next_loc counter in our State
dataclass, we maintain a purely functional approach while elegantly
handling the allocation challenge. This design demonstrates how
functional programming can manage state without side effects by making
state changes explicit in the return values of functions.</p>
<h3 id="initial-environment-setup">Initial Environment Setup</h3>
<p>In our functional implementation, the initial environment is built by
starting with an empty environment and extending it with each
operator:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_initial_env() <span class="op">-&gt;</span> Environment:</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Create an environment populated with standard operators&quot;&quot;&quot;</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    env <span class="op">=</span> empty_environment()</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    env <span class="op">=</span> bind(env, <span class="st">&quot;+&quot;</span>, add)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    env <span class="op">=</span> bind(env, <span class="st">&quot;-&quot;</span>, subtract)</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    env <span class="op">=</span> bind(env, <span class="st">&quot;*&quot;</span>, multiply)</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    env <span class="op">=</span> bind(env, <span class="st">&quot;/&quot;</span>, divide)</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>    env <span class="op">=</span> bind(env, <span class="st">&quot;%&quot;</span>, modulo)</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> env</span></code></pre></div>
<p>This builds up the environment incrementally, adding each binding
through functional extension.</p>
<h2 id="section-5-environment-based-interpretation">Section 5:
Environment-Based Interpretation</h2>
<p>Traditional interpreters often use pattern matching on operators
directly in the evaluation function. An environment-based approach takes
a more abstract view, treating operators as first-class values in the
environment.</p>
<h3 id="traditional-approach-from-chapter-3">Traditional Approach (from
Chapter 3)</h3>
<div class="sourceCode" id="cb63"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate(ast: Expression) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> ast:</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Number(value):</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> value</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> BinaryExpression(op, left, right):</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>            left_value <span class="op">=</span> evaluate(left)</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>            right_value <span class="op">=</span> evaluate(right)</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> op:</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>                <span class="cf">case</span> <span class="st">&quot;+&quot;</span>:</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> left_value <span class="op">+</span> right_value</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">case</span> <span class="st">&quot;-&quot;</span>:</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> left_value <span class="op">-</span> right_value</span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>                <span class="co"># ... other operations</span></span></code></pre></div>
<h3 id="environment-based-approach">Environment-Based Approach</h3>
<div class="sourceCode" id="cb64"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate(ast: Expression, env: Environment) <span class="op">-&gt;</span> MVal:</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> ast:</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Number(value):</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> value</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> BinaryExpression(op, left, right):</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Get operator from environment</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>                operator <span class="op">=</span> lookup(env, op)</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Ensure it&#39;s a DenOperator</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(operator, Callable):</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;</span><span class="sc">{</span>op<span class="sc">}</span><span class="ss"> is not a function&quot;</span>)</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Evaluate operands and apply operator</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>                left_value <span class="op">=</span> evaluate(left, env)</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>                right_value <span class="op">=</span> evaluate(right, env)</span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Apply the operator to the evaluated operands</span></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> operator(left_value, right_value)</span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> e:</span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Evaluation error: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="benefits-of-the-environment-based-approach">Benefits of the
Environment-Based Approach</h3>
<ul>
<li><strong>Extensibility</strong>: New operators can be added to the
environment without modifying the evaluator</li>
<li><strong>First-class operations</strong>: Operators are values that
can be passed, returned, and manipulated</li>
<li><strong>Consistent treatment</strong>: Operators and other
identifiers are handled uniformly</li>
<li><strong>Semantic clarity</strong>: The environment explicitly
represents the mapping from names to meanings</li>
</ul>
<h2 id="section-6-implementing-an-environment-based-interpreter">Section
6: Implementing an Environment-Based Interpreter</h2>
<p>Our <code>domains.py</code> file implements a complete
environment-based interpreter:</p>
<ol type="1">
<li><strong>Define semantic domains</strong>: Denotable and memorizable
values</li>
<li><strong>Implement operators</strong>: Define functions for
arithmetic operations</li>
<li><strong>Create the environment</strong>: Populate with standard
operators</li>
<li><strong>Evaluate expressions</strong>: Using the environment to look
up operators</li>
<li><strong>REPL</strong>: Interactive environment for testing the
interpreter</li>
</ol>
<h2 id="section-7-extending-the-interpreter">Section 7: Extending the
Interpreter</h2>
<p>This approach makes it easy to extend the language with new
features:</p>
<h3 id="adding-new-operators">Adding New Operators</h3>
<p>To add a new operator, simply define its function and add it to the
environment:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> power(x: <span class="bu">int</span>, y: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">**</span> y</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Extend environment</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>env <span class="op">=</span> bind(create_initial_env(), <span class="st">&quot;**&quot;</span>, power)</span></code></pre></div>
<div class="sourceCode" id="cb66"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">### Adding Variables</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>To support variables, extend the AST <span class="cf">with</span> a variable node <span class="kw">and</span> update the evaluator:</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>```python</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Variable:</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Update Expression type</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> Expression <span class="op">=</span> Number <span class="op">|</span> BinaryExpression <span class="op">|</span> Variable</span></code></pre></div>
<h1 id="update-evaluate-function">Update evaluate function</h1>
<div class="sourceCode" id="cb67"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate(ast: Expression, env: Environment) <span class="op">-&gt;</span> MVal:</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> ast:</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Variable(name):</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>            value <span class="op">=</span> lookup(env, name)</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Additional check might be needed if variables can only be Numbers</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(value, <span class="bu">int</span>):</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss"> is not a number&quot;</span>)</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> value</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... existing cases</span></span></code></pre></div>
<h2 id="additional-resources-1">Additional Resources</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Denotational_semantics">Denotational
Semantics (Wikipedia)</a></li>
<li><a href="https://web.stanford.edu/class/cs242/materials/lectures/lecture6.pdf">Programming
Language Semantics (Stanford)</a></li>
<li><a href="https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/interp/lambda_calculus.html">Functional
Programming and Lambda Calculus</a></li>
<li><a href="https://www.cs.tufts.edu/comp/105/readings/environments/environments.html">Environment
and Store in Programming Languages</a></li>
</ul>
<h2 id="section-9-practical-implementation-and-testing">Section 9:
Practical Implementation and Testing</h2>
<p>Our environment-based interpreter includes practical components for
execution and testing, demonstrating how theoretical concepts translate
to code.</p>
<h3 id="parsing-and-ast-construction">Parsing and AST Construction</h3>
<p>In our implementation, we use the Lark parser to convert text
expressions into parse trees:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_ast(expression: <span class="bu">str</span>) <span class="op">-&gt;</span> Expression:</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Parse a string expression into an AST&quot;&quot;&quot;</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    parse_tree <span class="op">=</span> parser.parse(expression)</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> transform_parse_tree(parse_tree)</span></code></pre></div>
<p>The <code>transform_parse_tree</code> function then converts these
parse trees into our AST representation, ready for evaluation.</p>
<h3 id="interactive-repl">Interactive REPL</h3>
<p>A Read-Eval-Print Loop allows interactive testing of the
interpreter:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> REPL():</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Read-Evaluate-Print Loop with environment&quot;&quot;&quot;</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    env <span class="op">=</span> create_initial_env()</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Mini-interpreter with environment (type &#39;exit&#39; to quit)&quot;</span>)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Available operators: +, -, *, /, %&quot;</span>)</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>        expression <span class="op">=</span> <span class="bu">input</span>(<span class="st">&quot;Enter an expression (exit to quit): &quot;</span>)</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> expression <span class="op">==</span> <span class="st">&quot;exit&quot;</span>:</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>            ast <span class="op">=</span> parse_ast(expression)</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> evaluate(ast, env)</span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(result)</span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;Error: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<p>The REPL shows how our environment-based interpreter integrates with
user interaction.</p>
<h3 id="automated-tests">Automated Tests</h3>
<p>Testing ensures the interpreter behaves as expected across various
expressions:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_tests():</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Run test expressions to verify the parser and evaluator&quot;&quot;&quot;</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    test_expressions <span class="op">=</span> [</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;1+2&quot;</span>,</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;3*4&quot;</span>,</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;5-3&quot;</span>,</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;10/2&quot;</span>,</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;10%3&quot;</span>,</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;(1+2)*3&quot;</span>,</span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;1+(2*3)&quot;</span>,</span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;10/(2+3)&quot;</span>,</span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;10%(2+3)&quot;</span>,</span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>    env <span class="op">=</span> create_initial_env()</span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> expr <span class="kw">in</span> test_expressions:</span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a>            ast <span class="op">=</span> parse_ast(expr)</span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> evaluate(ast, env)</span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="sc">{</span>expr<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>result<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb70-23"><a href="#cb70-23" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="sc">{</span>expr<span class="sc">}</span><span class="ss"> -&gt; Error: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<p>These tests validate core functionality while providing examples of
valid expressions.</p>
<h2 id="section-10-conclusion-and-next-steps">Section 10: Conclusion and
Next Steps</h2>
<h3 id="summary-of-key-concepts">Summary of Key Concepts</h3>
<p>In this chapter, we’ve explored:</p>
<ol type="1">
<li><strong>Semantic domains</strong> as mathematical structures that
give meaning to programs</li>
<li><strong>Environment-based interpretation</strong> as a flexible
approach to language implementation</li>
<li><strong>Functional representations</strong> of environments and
state</li>
<li><strong>Primitive operations</strong> for manipulating environments
and memory</li>
<li><strong>The distinction</strong> between denotable and memorizable
values</li>
</ol>
<p>These concepts form the foundation for understanding more complex
language features in subsequent chapters.</p>
<h3 id="looking-forward">Looking Forward</h3>
<p>The environment-based approach introduced here will be extended in
future chapters to support:</p>
<ol type="1">
<li><strong>Variables and assignment</strong>: Using environments to
bind identifiers to memory locations</li>
<li><strong>Scoping mechanisms</strong>: Creating nested environments
for block-structured code</li>
<li><strong>Functions and closures</strong>: Capturing environments for
later execution</li>
<li><strong>Typing systems</strong>: Adding constraints on what values
expressions can produce</li>
</ol>
<p>By building on these semantic foundations, we can construct a rich
understanding of programming language design and implementation.</p>
<h3 id="exercises-for-the-reader">Exercises for the Reader</h3>
<ol type="1">
<li>Extend the interpreter to support variables using the Variable AST
node described in Section 7</li>
<li>Add support for multi-character operators (e.g., “**” for
exponentiation)</li>
<li>Implement a memory system with the primitives described in Section
8</li>
<li>Add support for conditional expressions (if-then-else)</li>
<li>Implement a simple block structure with local variables</li>
</ol>
<p>These exercises will deepen your understanding of language semantics
and interpreter design while preparing you for more advanced topics in
the next chapters.</p>
<h1 id="chapter-5-variable-binding-and-let-expressions">Chapter 5:
Variable Binding and Let Expressions</h1>
<h2 id="section-1-introduction-to-variable-binding">Section 1:
Introduction to Variable Binding</h2>
<p>In this chapter, we extend our mini-interpreter to support
<strong>variable binding</strong> through <code>let</code> expressions.
This is a fundamental capability that allows programs to:</p>
<ol type="1">
<li>Name and reuse values</li>
<li>Create modular components</li>
<li>Build abstractions that hide implementation details</li>
</ol>
<p>The extension represents our first step toward a more practical and
powerful language.</p>
<h3 id="variable-binding-vs.-assignment">Variable Binding
vs. Assignment</h3>
<p>It’s important to distinguish between binding and assignment:</p>
<ul>
<li><p><strong>Variable Binding</strong>: Associates a name with a value
in a specific scope or environment</p>
<pre><code>let x = 10 in ...</code></pre></li>
<li><p><strong>Assignment</strong>: Changes the value associated with an
existing name</p>
<pre><code>x = 10</code></pre></li>
</ul>
<p>In our mini-language, we implement variable binding but not
assignment. This makes our language more functional in nature and
simplifies reasoning about program behavior.</p>
<h2 id="section-2-let-expressions">Section 2: Let Expressions</h2>
<h3 id="syntax-and-semantics-of-let-expressions">Syntax and Semantics of
Let Expressions</h3>
<p>We extend our grammar with <code>let</code> expressions:</p>
<pre><code>let: &quot;let&quot; IDENTIFIER &quot;=&quot; expr &quot;in&quot; expr</code></pre>
<p>A <code>let</code> expression has three components: 1. The name
(identifier) being bound 2. The expression that provides the value to
bind 3. The body expression where the binding is in scope</p>
<p>For example, in <code>let x = 10 in x + 5</code>, we: - Bind
<code>x</code> to the value <code>10</code> - Evaluate the body
<code>x + 5</code> in this extended environment, resulting in
<code>15</code></p>
<h3 id="ast-representation">AST Representation</h3>
<p>To support <code>let</code> expressions in our abstract syntax tree,
we add a new class:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Let:</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    expr: Expression</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>    body: Expression</span></code></pre></div>
<p>And we extend our <code>Expression</code> type to include
<code>Let</code> and <code>Var</code> (variable reference) nodes:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> Expression <span class="op">=</span> Number <span class="op">|</span> BinaryExpression <span class="op">|</span> Let <span class="op">|</span> Var</span></code></pre></div>
<h3 id="variable-references">Variable References</h3>
<p>To use bound variables, we need to support variable references in our
language:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Var:</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span></code></pre></div>
<p>When evaluating a variable reference, we look up its value in the
current environment:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> Var(name):</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> lookup(env, name)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> x:</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="bu">int</span>():</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> _:</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Unexpected value type: </span><span class="sc">{</span><span class="bu">type</span>(x)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h2 id="section-3-the-environment">Section 3: The Environment</h2>
<h3 id="environment-as-a-first-class-citizen">Environment as a
First-Class Citizen</h3>
<p>In our mini-interpreter, the environment is a first-class entity
that’s explicitly passed around during evaluation. This makes the
binding context explicit in our semantics.</p>
<p>The key operations on environments are: - <strong>Creation</strong>:
Building an initial environment with primitive operations -
<strong>Lookup</strong>: Finding the value associated with a name -
<strong>Extension</strong>: Adding new bindings to create a derived
environment</p>
<h3 id="environment-implementation">Environment Implementation</h3>
<p>Our environment is implemented as a function that maps names to
values:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> Environment <span class="op">=</span> Callable[[<span class="bu">str</span>], DVal]</span></code></pre></div>
<p>We extend the environment when evaluating a <code>let</code>
expression:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> Let(name, expr, body):</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    value <span class="op">=</span> evaluate(expr, env)</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    extended_env <span class="op">=</span> bind(env, name, value)</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> evaluate(body, extended_env)</span></code></pre></div>
<p>This creates a new environment that includes the original bindings
plus the new binding.</p>
<h3 id="static-vs.-dynamic-scoping">Static vs. Dynamic Scoping</h3>
<p>Our implementation uses <strong>lexical (static) scoping</strong>,
where variable references are resolved in the environment where they are
defined, not where they are used.</p>
<p>This is in contrast to <strong>dynamic scoping</strong>, where
variable references are resolved in the current execution
environment.</p>
<p>Lexical scoping is more predictable and easier to reason about, which
is why it’s the dominant approach in modern programming languages.</p>
<h4 id="static-vs.-dynamic-scoping-examples">Static vs. Dynamic Scoping
Examples</h4>
<p>Consider this expression:</p>
<pre><code>let x = 5 in 
  let f = (let y = 10 in y + x) in
    let x = 42 in
      f</code></pre>
<p>With <strong>static scoping</strong> (our implementation), this
evaluates to: - <code>f</code> is bound to the result of
<code>(let y = 10 in y + x)</code> where <code>x</code> is 5, so
<code>f</code> is 15 - Even though we later rebind <code>x</code> to 42,
the reference to <code>x</code> inside <code>f</code> still refers to
the original binding - Final result: 15</p>
<p>With <strong>dynamic scoping</strong>, this would evaluate to: -
<code>f</code> is bound to the expression
<code>(let y = 10 in y + x)</code> (not its value yet) - When
<code>f</code> is evaluated, it looks for the current binding of
<code>x</code>, which is 42 - Final result: 52</p>
<p>Another example:</p>
<pre><code>let a = 1 in
  let f = (a + 10) in
    let a = 100 in
      f</code></pre>
<p>With <strong>static scoping</strong>: - <code>f</code> evaluates to
11 using the binding <code>a = 1</code> - The later binding of
<code>a = 100</code> has no effect on <code>f</code></p>
<p>With <strong>dynamic scoping</strong>: - <code>f</code> would be 110
since it would use the latest binding of <code>a</code> when
evaluated</p>
<p><strong>Examples</strong></p>
<p>Let expressions dramatically increase the expressiveness of our
language. Consider a few examples:</p>
<pre><code>let x = 10 in x + 5</code></pre>
<p>Evaluates to 15 by binding x to 10 and adding 5.</p>
<pre><code>let x = 1 in let y = 2 in x + y</code></pre>
<p>Nested binding.</p>
<h2 id="section-5-conclusion">Section 5: Conclusion</h2>
<p>Adding variable binding through let expressions marks a significant
step in the evolution of our mini-language. In future chapters, we’ll
build on this foundation to add more capabilities:</p>
<ul>
<li>Conditionals and booleans</li>
<li>Iteration (while and for loops)</li>
<li>Functions and application</li>
<li>Recursion</li>
</ul>
<h3 id="parser-and-grammar-extensions">Parser and Grammar
Extensions</h3>
<p>Compared to Lecture 4, we’ve made the following extensions to the
parser and grammar:</p>
<ol type="1">
<li>Added a new production rule for <code>let</code> expressions:</li>
</ol>
<pre><code>let: &quot;let&quot; IDENTIFIER &quot;=&quot; expr &quot;in&quot; expr</code></pre>
<ol start="2" type="1">
<li>Extended the expression rule to include both variables and let
expressions:</li>
</ol>
<pre><code>?expr: bin | mono | let 
mono: ground | paren | var
var: IDENTIFIER</code></pre>
<ol start="3" type="1">
<li>Added new pattern matching cases in the parse tree transformation
function:</li>
</ol>
<div class="sourceCode" id="cb86"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> Tree(data<span class="op">=</span><span class="st">&quot;var&quot;</span>, children<span class="op">=</span>[Token(<span class="bu">type</span><span class="op">=</span><span class="st">&quot;IDENTIFIER&quot;</span>, value<span class="op">=</span>name)]):</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Var(name<span class="op">=</span>name)</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> Tree(</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    data<span class="op">=</span><span class="st">&quot;let&quot;</span>,</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    children<span class="op">=</span>[</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>        Token(<span class="bu">type</span><span class="op">=</span><span class="st">&quot;IDENTIFIER&quot;</span>, value<span class="op">=</span>name),</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>        expr,</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>        body,</span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>):</span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Let(</span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>        name<span class="op">=</span>name,</span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>        expr<span class="op">=</span>transform_parse_tree(expr),</span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>        body<span class="op">=</span>transform_parse_tree(body),</span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div>
<ol start="4" type="1">
<li>Added evaluation rules for the new AST node types:</li>
</ol>
<div class="sourceCode" id="cb87"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> Let(name, expr, body):</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>    value <span class="op">=</span> evaluate(expr, env)</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    extended_env <span class="op">=</span> bind(env, name, value)</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> evaluate(body, extended_env)</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> Var(name):</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> lookup(env, name)</span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> x:</span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="bu">int</span>():</span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x</span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> _:</span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Unexpected value type: </span><span class="sc">{</span><span class="bu">type</span>(x)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<p>These extensions allow our language to support both variable
definitions and references while maintaining the core evaluation
semantics from Lecture 4 that will be useful in the second part of the
course.</p>
<h1 id="chapter-6-state">Chapter 6: State</h1>
<h2 id="section-1-introduction-to-state">Section 1: Introduction to
State</h2>
<p>In this chapter, we extend our mini-language with the concept of
<strong>state</strong>. Until now, our language has been purely
functional, where expressions are evaluated to produce values without
side effects. By adding state, we can:</p>
<ol type="1">
<li>Store and update values in memory</li>
<li>Observe changes to data over time</li>
<li>Model real-world systems that have changing state</li>
</ol>
<h3 id="expressions-vs.-commands">Expressions vs. Commands</h3>
<p>Our language extension introduces a new distinction:</p>
<ul>
<li><strong>Expressions</strong>: Compute values (e.g.,
<code>x + 1</code>, <code>let x = 42 in x * 2</code>)</li>
<li><strong>Commands</strong>: Perform actions with side effects (e.g.,
<code>var x = 42</code>, <code>x &lt;- 42</code>,
<code>print x</code>)</li>
</ul>
<p>This distinction is common in many programming languages:</p>
<pre><code># Expression (computes a value)
x + 1

# Command (performs an action)
var x = 42
x &lt;- 42</code></pre>
<h2 id="section-2-commands-and-command-sequences">Section 2: Commands
and Command Sequences</h2>
<p>To implement state, we introduce two new syntactic categories:</p>
<ol type="1">
<li><strong>Commands</strong>: Individual actions that can modify
state</li>
<li><strong>Command Sequences</strong>: Ordered lists of commands to be
executed in sequence</li>
</ol>
<h3 id="commands-in-our-language">Commands in Our Language</h3>
<p>We implement three basic command types:</p>
<ol type="1">
<li><p><strong>Variable Declaration</strong>: Declares a new variable
and initializes it</p>
<pre><code>var x = 42</code></pre></li>
<li><p><strong>Assignment</strong>: Updates a variable with a new value
(only if already declared)</p>
<pre><code>x &lt;- 10</code></pre></li>
<li><p><strong>Print</strong>: Outputs the value of an expression</p>
<pre><code>print x + 1</code></pre></li>
</ol>
<h3 id="command-sequences">Command Sequences</h3>
<p>Command sequences represent multiple commands separated by
semicolons:</p>
<pre><code>var x = 10;
var y = x + 5;
print y</code></pre>
<p>This sequence declares <code>x</code>, then declares <code>y</code>
as <code>x + 5</code> (which is 15), and finally prints the value of
<code>y</code>.</p>
<h3 id="grammar-extensions">Grammar Extensions</h3>
<p>We extend our language grammar to support commands and sequences:</p>
<pre><code>?program: command_seq

?command_seq: command
           | command &quot;;&quot; command_seq

?command: assign
        | print
        | vardecl

assign: IDENTIFIER &quot;&lt;-&quot; expr
print: &quot;print&quot; expr
vardecl: &quot;var&quot; IDENTIFIER &quot;=&quot; expr</code></pre>
<h3 id="ast-representation-1">AST Representation</h3>
<p>We represent commands and command sequences with these AST node
types:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Assign:</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>    expr: Expression</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Print:</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>    expr: Expression</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VarDecl:</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a>    expr: Expression</span></code></pre></div>
<div class="sourceCode" id="cb95"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CommandSequence:</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>    first: Command</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>    rest: Optional[CommandSequence] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> Command <span class="op">=</span> Assign <span class="op">|</span> Print <span class="op">|</span> VarDecl</span></code></pre></div>
<h2 id="section-3-the-store-model-of-state">Section 3: The Store Model
of State</h2>
<p>To represent state, we use the “store model”:</p>
<ol type="1">
<li><strong>Environment</strong>: Maps variable names to locations
(memory addresses)</li>
<li><strong>Store</strong>: Maps locations to values</li>
</ol>
<p>This two-level indirection allows multiple variables to refer to the
same location or for a variable’s value to change without changing its
location.</p>
<h3 id="the-state-as-a-functional-dataclass">The State as a Functional
Dataclass</h3>
<p>Our implementation uses a <code>State</code> dataclass to manage the
store in a functional style:</p>
<ul>
<li>The store is <strong>not</strong> a dictionary, but a function from
locations to values (or raises an error if not found), just like the
environment is a function from names to locations. This ensures a fully
functional approach.</li>
</ul>
<div class="sourceCode" id="cb96"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> State:</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>    store: Callable[[<span class="bu">int</span>], MVal]</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>    next_loc: <span class="bu">int</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> empty_store() <span class="op">-&gt;</span> Callable[[<span class="bu">int</span>], MVal]:</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> store_fn(loc: <span class="bu">int</span>) <span class="op">-&gt;</span> MVal:</span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Location </span><span class="sc">{</span>loc<span class="sc">}</span><span class="ss"> not allocated&quot;</span>)</span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> store_fn</span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> empty_state() <span class="op">-&gt;</span> State:</span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> State(store<span class="op">=</span>empty_store(), next_loc<span class="op">=</span><span class="dv">0</span>)</span></code></pre></div>
<div class="sourceCode" id="cb97"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> allocate(state: State, value: MVal) <span class="op">-&gt;</span> <span class="bu">tuple</span>[Loc, State]:</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>    loc <span class="op">=</span> Loc(state.next_loc)</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>    prev_store <span class="op">=</span> state.store</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> new_store(l: <span class="bu">int</span>) <span class="op">-&gt;</span> MVal:</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> l <span class="op">==</span> loc.address:</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> value</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> prev_store(l)</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> loc, State(store<span class="op">=</span>new_store, next_loc<span class="op">=</span>loc.address <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb98"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update(state: State, addr: <span class="bu">int</span>, value: MVal) <span class="op">-&gt;</span> State:</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>    prev_store <span class="op">=</span> state.store</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> new_store(l: <span class="bu">int</span>) <span class="op">-&gt;</span> MVal:</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> l <span class="op">==</span> addr:</span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> value</span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> prev_store(l)</span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> State(store<span class="op">=</span>new_store, next_loc<span class="op">=</span>state.next_loc)</span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> access(state: State, addr: <span class="bu">int</span>) <span class="op">-&gt;</span> MVal:</span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> state.store(addr)</span></code></pre></div>
<h3 id="denotable-values-dval-1">Denotable Values (DVal)</h3>
<p>Denotable values are those that can be bound to identifiers in an
environment. Our language now has three distinct semantic domains:</p>
<ul>
<li><strong>EVal (Expressible Values)</strong>: Values that expressions
can evaluate to (integers in our language)</li>
<li><strong>MVal (Memorizable Values)</strong>: Values that can be
stored in memory (equal to EVal in our implementation)</li>
<li><strong>DVal (Denotable Values)</strong>: Values that can be bound
to identifiers in the environment</li>
</ul>
<p>DVal is broader than MVal because not everything that can be bound to
a name can be stored in memory. Specifically, DVal includes:</p>
<ul>
<li><strong>Numbers</strong>: Simple integer values (EVal)</li>
<li><strong>Operators</strong>: Functions that take two integers and
return an integer</li>
<li><strong>Locations</strong>: Memory addresses (wrapped in a Loc
class)</li>
</ul>
<p>The distinction between these domains is crucial for implementing
state correctly:</p>
<ul>
<li>Expressions evaluate to EVal (integers)</li>
<li>Memory cells store MVal (integers)</li>
<li>Variable names can refer to DVal (integers, operators, or
locations)</li>
</ul>
<div class="sourceCode" id="cb99"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Loc:</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    address: <span class="bu">int</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> DenOperator <span class="op">=</span> Callable[[<span class="bu">int</span>, <span class="bu">int</span>], <span class="bu">int</span>]</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> EVal <span class="op">=</span> <span class="bu">int</span>  <span class="co"># Expressible value type (for expressions)</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> MVal <span class="op">=</span> EVal  <span class="co"># Main value type for store and evaluation (expressible)</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> DVal <span class="op">=</span> EVal <span class="op">|</span> DenOperator <span class="op">|</span> Loc  <span class="co"># Denotable values: can be associated with names</span></span></code></pre></div>
<p>Rather than representing memory locations as plain integers, we wrap
them in the <code>Loc</code> class for two important reasons:</p>
<ol type="1">
<li><strong>Pattern Matching</strong>: It allows the pattern matcher to
distinguish locations from integer values</li>
<li><strong>Type Safety</strong>: It prevents accidentally using a
location as an integer or vice versa</li>
</ol>
<p>This distinction becomes essential in variable lookup. When we look
up a variable, we need to determine if the value bound to it is:</p>
<ul>
<li>A direct integer value (for operators like +, -, etc.)</li>
<li>A location that requires a further lookup in the store</li>
</ul>
<p>Without the <code>Loc</code> wrapper class, the pattern matcher
wouldn’t be able to distinguish between an integer value and an integer
location in memory.</p>
<h2 id="section-4-evaluating-expressions-with-state">Section 4:
Evaluating Expressions with State</h2>
<p>When evaluating expressions in a stateful language, we need to pass
both the environment and the state:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_expr(expr: Expression, env: Environment, state: State) <span class="op">-&gt;</span> EVal:</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span></code></pre></div>
<p>Variable lookup now has two steps:</p>
<ol type="1">
<li>Use the environment to find the location or directly bound
value</li>
<li>If it’s a location, use the state to look up the value at that
location</li>
</ol>
<div class="sourceCode" id="cb101"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> Var(name):</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>        dval <span class="op">=</span> lookup(env, name)</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> dval:</span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="bu">int</span>():</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> dval</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> Loc(address<span class="op">=</span>addr):</span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> access(state, addr)</span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> _:</span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Variable &#39;</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&#39; does not refer to a value&quot;</span>)</span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> e:</span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Variable error: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h2 id="section-5-executing-commands">Section 5: Executing Commands</h2>
<p>Commands modify the state or produce output. The
<code>execute_command</code> function returns both the updated
environment and state as a tuple:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> execute_command(</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>    cmd: Command, env: Environment, state: State</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">tuple</span>[Environment, State]:</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ...</span></span></code></pre></div>
<h3 id="the-variable-declaration-command">The Variable Declaration
Command</h3>
<p>The variable declaration command (<code>var x = expr</code>) creates
a new variable and initializes it:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> VarDecl(name, expr):</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>    value <span class="op">=</span> evaluate_expr(expr, env, state)</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    loc, state <span class="op">=</span> allocate(state, value)</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>    new_env <span class="op">=</span> bind(env, name, loc)</span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_env, state</span></code></pre></div>
<h3 id="the-assignment-command">The Assignment Command</h3>
<p>The assignment command (<code>&lt;-</code>) only updates an existing
variable:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> Assign(name, expr):</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>        dval <span class="op">=</span> lookup(env, name)</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> dval:</span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> Loc(address<span class="op">=</span>addr) <span class="im">as</span> loc:</span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>                value <span class="op">=</span> evaluate_expr(expr, env, state)</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>                state1 <span class="op">=</span> update(state, addr, value)</span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> env, state1</span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> _:</span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(</span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a>                    <span class="ss">f&quot;Assignment target &#39;</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&#39; is not a variable&quot;</span></span>
<span id="cb104-12"><a href="#cb104-12" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb104-13"><a href="#cb104-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">ValueError</span>:</span>
<span id="cb104-14"><a href="#cb104-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Assignment to undeclared variable &#39;</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">&#39;&quot;</span>)</span></code></pre></div>
<h3 id="the-print-command">The Print Command</h3>
<p>The print command evaluates the expression and prints its value:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> Print(expr):</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># MORALLY THIS IS THE IDENTITY FUNCTION</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>    value <span class="op">=</span> evaluate_expr(expr, env, state)</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(value)</span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> env, state</span></code></pre></div>
<h3 id="command-sequences-1">Command Sequences</h3>
<p>Executing a command sequence involves:</p>
<ol type="1">
<li>Executing the first command</li>
<li>Executing the rest of the sequence with the updated environment and
state</li>
</ol>
<div class="sourceCode" id="cb106"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> execute_command_seq(</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    seq: CommandSequence, env: Environment, state: State</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">tuple</span>[Environment, State]:</span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Execute the first command</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>    env1, state1 <span class="op">=</span> execute_command(seq.first, env, state)</span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If there are more commands, execute them with the updated environment and state</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> seq.rest:</span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> execute_command_seq(seq.rest, env1, state1)</span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> env1, state1</span></code></pre></div>
<h2 id="section-6-examples-of-state-in-action">Section 6: Examples of
State in Action</h2>
<p>Let’s look at some examples that demonstrate the power of state:</p>
<h3 id="example-1-basic-declaration-assignment-and-printing">Example 1:
Basic Declaration, Assignment, and Printing</h3>
<pre><code>var x = 42; print x</code></pre>
<p>This simple example shows creating a variable and reading its value.
The output is <code>42</code>.</p>
<h3 id="example-2-updating-variables">Example 2: Updating Variables</h3>
<pre><code>var x = 10; print x; x &lt;- 20; print x</code></pre>
<p>This example demonstrates updating a variable’s value. The output
is:</p>
<pre><code>10
20</code></pre>
<h3 id="example-3-multiple-declarations-and-operations">Example 3:
Multiple Declarations and Operations</h3>
<pre><code>var x = 10; var y = 20; var z = x + y; print z; x &lt;- 30; print x + y</code></pre>
<p>The output of this program is:</p>
<pre><code>30
50</code></pre>
<p>Notice that changing <code>x</code> doesn’t automatically update
<code>z</code>, even though <code>z</code> was defined in terms of
<code>x</code> and <code>y</code>.</p>
<h3 id="example-4-let-expressions-in-commands">Example 4: Let
Expressions in Commands</h3>
<pre><code>var x = let y = 5 in y * 2; print x</code></pre>
<p>This example shows how we can use let expressions within commands.
The output is <code>10</code>.</p>
<h2 id="section-7-differences-from-previous-chapters">Section 7:
Differences from Previous Chapters</h2>
<p>Adding state represents a significant shift in our language:</p>
<table>
<colgroup>
<col style="width: 47%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th>Purely Functional (Ch. 5)</th>
<th>Stateful (Ch. 6)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Values are immutable</td>
<td>Values can change over time</td>
</tr>
<tr>
<td>No side effects</td>
<td>Commands have side effects</td>
</tr>
<tr>
<td>Referential transparency</td>
<td>Expressions may evaluate differently</td>
</tr>
<tr>
<td>Environment maps names to values</td>
<td>Environment maps names to locations</td>
</tr>
<tr>
<td>Easier to reason about</td>
<td>More expressive</td>
</tr>
</tbody>
</table>
<h2 id="section-8-conclusion-and-next-steps">Section 8: Conclusion and
Next Steps</h2>
<p>Adding state to our mini-language significantly increases its
expressiveness, making it capable of modeling real-world problems that
involve change over time. In the next chapter, we’ll build upon this
foundation by adding control flow structures like loops and
conditionals.</p>
<p>With state, environment, and control flow, our language will have all
the essential ingredients of a complete programming language.</p>
<h2 id="exercises-1">Exercises</h2>
<h3 id="interactive-repl-1">1) Interactive REPL</h3>
<p>Modify the REPL implementation to operate one command at a time
instead of parsing and executing entire programs.</p>
<h3 id="aliasing">2) Aliasing</h3>
<p>Add the command</p>
<pre><code>alias x = y</code></pre>
<p>where <code>x</code> and <code>y</code> are variables. The semantics
is that after executing the command, both names x and y point to the
same location, so assigning to one of them assigns also to the other
one.</p>
<p>Make an example where this becomes apparent</p>
<p>Now consider the program</p>
<pre><code>var x = 0;
alias y = x;
x &lt;- x+1;
y &lt;- y+1;
var y = x;
x &lt;- x+1;
print y</code></pre>
<p>QUESTION: which value is printed?</p>
<h3 id="multiple-assignment">3) Multiple Assignment</h3>
<p>Implement multiple assignment where multiple variables can be
assigned at once:</p>
<pre><code>x, y &lt;- z + 1, x + 1</code></pre>
<h3 id="parallel-assignment">4) Parallel Assignment</h3>
<p>Make the assignment “parallel” so that all right-hand sides are
evaluated before any assignments happen; note that the variables x and y
must be different in that case:</p>
<pre><code>x, y &lt;- y + 1, x + 1</code></pre>
<p>This should swap the values of x and y.</p>
<h3 id="if-then-else-statements">5) If-Then-Else Statements</h3>
<p>Add if-then-else statements to the language:</p>
<pre><code>if x &gt; 0 then
    y &lt;- 1
else
    y &lt;- -1</code></pre>
<h3 id="command-sequences-in-branches">5) Command Sequences in
Branches</h3>
<p>Extend if-then-else to support command sequences in the branches and
consider the implications for variable scoping.</p>
<h1 id="chapter-7-control-flow">Chapter 7: Control Flow</h1>
<h2 id="introduction-to-control-flow">1. Introduction to Control
Flow</h2>
<p>In the previous chapters, we introduced <strong>state</strong> to our
mini-language, allowing variables to be declared, updated, and printed.
However, all programs executed commands in a fixed, linear order.</p>
<p>In this chapter, we enrich our language with <strong>control flow
constructs</strong>—specifically, conditionals
(<code>if</code>/<code>else</code>) and loops (<code>while</code>).
These features allow programs to make decisions and repeat actions,
greatly increasing their expressive power.</p>
<p>We also introduce <strong>block-local variables</strong> and extend
the language to support boolean values and unified operators
(arithmetic, relational, and boolean). This chapter marks a significant
step toward a full-featured imperative language.</p>
<p><strong>Summary of new features:</strong></p>
<ul>
<li><code>if</code>/<code>else</code> and <code>while</code>
commands</li>
<li>Boolean values and expressions</li>
<li>Unified operator handling</li>
<li>Block-local variable scoping (static/lexical scope)</li>
</ul>
<h2 id="control-flow-constructs">2. Control Flow Constructs</h2>
<h3 id="if-then-else">2.1 If-Then-Else</h3>
<p>The <code>if</code> command allows a program to choose between two
branches based on a boolean condition. The syntax is:</p>
<pre><code>if &lt;condition&gt; then &lt;commands&gt; else &lt;commands&gt;</code></pre>
<ul>
<li>The <code>&lt;condition&gt;</code> must be a boolean
expression.</li>
<li>Both the <code>then</code> and <code>else</code> branches can
contain sequences of commands.</li>
</ul>
<h4 id="implementation-if-then-else">Implementation: If-Then-Else</h4>
<div class="sourceCode" id="cb119"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> IfElse:</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>    cond: Expression</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>    then_branch: CommandSequence</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>    else_branch: CommandSequence</span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a><span class="co"># ...</span></span></code></pre></div>
<div class="sourceCode" id="cb120"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> execute_command(cmd: Command, env: Environment, state: State) <span class="op">-&gt;</span> <span class="bu">tuple</span>[Environment, State]:</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> cmd:</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> IfElse(cond, then_branch, else_branch):</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>            cond_val <span class="op">=</span> evaluate_expr(cond, env, state)</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(cond_val, <span class="bu">bool</span>):</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&quot;If condition must be boolean&quot;</span>)</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>            saved_next_loc <span class="op">=</span> state.next_loc</span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> cond_val:</span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>                _, state1 <span class="op">=</span> execute_command_seq(then_branch, env, state)</span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Restore next_loc after block</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>                state2 <span class="op">=</span> State(store<span class="op">=</span>state1.store, next_loc<span class="op">=</span>saved_next_loc)</span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> env, state2</span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a>                _, state1 <span class="op">=</span> execute_command_seq(else_branch, env, state)</span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a>                state2 <span class="op">=</span> State(store<span class="op">=</span>state1.store, next_loc<span class="op">=</span>saved_next_loc)</span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> env, state2</span></code></pre></div>
<p>This ensures that variables declared inside a branch are only visible
within that branch, and their memory is reclaimed after the branch
ends.</p>
<p><strong>Example:</strong></p>
<pre><code>var x = 1;
if x == 1 then print 42 else print 0</code></pre>
<p>This program prints <code>42</code> because the condition
<code>x == 1</code> is true.</p>
<h3 id="while-loops">2.2 While Loops</h3>
<p>The <code>while</code> command allows repeated execution of a block
of commands as long as a condition holds:</p>
<pre><code>while &lt;condition&gt; do &lt;commands&gt;</code></pre>
<ul>
<li>The <code>&lt;condition&gt;</code> must be a boolean
expression.</li>
<li>The body can be a sequence of commands.</li>
</ul>
<h4 id="implementation-while-loops">Implementation: While Loops</h4>
<div class="sourceCode" id="cb123"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> While:</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>    cond: Expression</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    body: CommandSequence</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a><span class="co"># ...</span></span></code></pre></div>
<div class="sourceCode" id="cb124"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> execute_command(cmd: Command, env: Environment, state: State) <span class="op">-&gt;</span> <span class="bu">tuple</span>[Environment, State]:</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> cmd:</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> While(cond, body):</span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>            cond_val <span class="op">=</span> evaluate_expr(cond, env, state)</span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(cond_val, <span class="bu">bool</span>):</span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&quot;While condition must be boolean&quot;</span>)</span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>            saved_next_loc <span class="op">=</span> state.next_loc</span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> cond_val:</span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a>                _, state1 <span class="op">=</span> execute_command_seq(body, env, state)</span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Restore next_loc after block</span></span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a>                state2 <span class="op">=</span> State(store<span class="op">=</span>state1.store, next_loc<span class="op">=</span>saved_next_loc)</span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> execute_command(While(cond, body), env, state2)</span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> env, state</span></code></pre></div>
<p><strong>Example:</strong></p>
<pre><code>var n = 3;
while n &gt; 0 do
    print n;
    n &lt;- n - 1</code></pre>
<p>This program prints <code>3</code>, <code>2</code>, and
<code>1</code> on separate lines.</p>
<h2 id="block-local-variables-and-scoping">3. Block-Local Variables and
Scoping</h2>
<p>A major semantic change in this chapter is the introduction of
<strong>block-local variables</strong>. Variables declared inside a
block (such as the body of an <code>if</code>, <code>else</code>, or
<code>while</code>) are only visible within that block. This is known as
<strong>static (lexical) scoping</strong>.</p>
<ul>
<li>When a block ends, its local variables are no longer
accessible.</li>
<li>The implementation reuses memory locations for block-local variables
by resetting the next available location counter after a block ends.
This models stack allocation and prevents unbounded memory growth.</li>
</ul>
<h4 id="implementation-block-local-variables-and-lexical-scoping">Implementation:
Block-Local Variables and Lexical Scoping</h4>
<p>Block-local variables are managed using a stack-like memory model.
Recall how allocation and deallocation work:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> State:</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    store: Callable[[<span class="bu">int</span>], MVal]</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>    next_loc: <span class="bu">int</span></span></code></pre></div>
<div class="sourceCode" id="cb127"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> allocate(state: State, value: MVal) <span class="op">-&gt;</span> <span class="bu">tuple</span>[Loc, State]:</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>    loc <span class="op">=</span> Loc(state.next_loc)</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>    prev_store <span class="op">=</span> state.store</span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> new_store(l: <span class="bu">int</span>) <span class="op">-&gt;</span> MVal:</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> l <span class="op">==</span> loc.address:</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> value</span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> prev_store(l)</span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> loc, State(store<span class="op">=</span>new_store, next_loc<span class="op">=</span>loc.address <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<ul>
<li><strong>Allocation</strong>: Each new variable gets a fresh location
(<code>next_loc</code>), which is incremented.</li>
<li><strong>Deallocation</strong>: After a block, <code>next_loc</code>
is reset, so locations for block-local variables can be reused.</li>
</ul>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb128"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> cond then</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>    var x <span class="op">=</span> <span class="dv">42</span><span class="op">;</span> <span class="bu">print</span> x</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span> <span class="dv">0</span></span></code></pre></div>
<p>Here, <code>x</code> is only accessible inside the <code>then</code>
branch. After the branch, its memory location can be reused for other
variables.</p>
<h3 id="digression-memory-safety-and-buffer-over-read">Digression:
Memory Safety and Buffer Over-Read</h3>
<p>A <strong>buffer over-read</strong> occurs when a program reads data
past the end of a buffer (an array or memory region), often due to
incorrect pointer arithmetic or missing bounds checks. In C, this is a
common source of security vulnerabilities, especially when working with
stack-allocated arrays.</p>
<p><strong>Example: Buffer Over-Read in C</strong></p>
<div class="sourceCode" id="cb129"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_secret<span class="op">()</span> <span class="op">{</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> buffer<span class="op">[</span><span class="dv">8</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> secret<span class="op">[</span><span class="dv">8</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;SECRET!&quot;</span><span class="op">;</span></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">16</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c</span><span class="st">&quot;</span><span class="op">,</span> buffer<span class="op">[</span>i<span class="op">]);</span> <span class="co">// Over-reads into secret</span></span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb129-10"><a href="#cb129-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb129-11"><a href="#cb129-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-12"><a href="#cb129-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb129-13"><a href="#cb129-13" aria-hidden="true" tabindex="-1"></a>    print_secret<span class="op">();</span></span>
<span id="cb129-14"><a href="#cb129-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb129-15"><a href="#cb129-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Output:</strong></p>
<pre><code>helloSECRET!</code></pre>
<p>Here, the loop prints not only the contents of <code>buffer</code>,
but also the contents of the adjacent <code>secret</code> array, which
is stored on the stack. This is a classic buffer over-read: the program
leaks data from memory that should have been inaccessible, illustrating
why careful memory management and scoping are crucial.</p>
<h2 id="unified-operators-and-boolean-expressions">4. Unified Operators
and Boolean Expressions</h2>
<p>Our language now supports a unified set of operators:</p>
<ul>
<li><strong>Arithmetic:</strong> <code>+</code>, <code>-</code>,
<code>*</code>, <code>/</code>, <code>%</code></li>
<li><strong>Relational:</strong> <code>==</code>, <code>!=</code>,
<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,
<code>&gt;=</code></li>
<li><strong>Boolean:</strong> <code>and</code>, <code>or</code>,
<code>not</code></li>
</ul>
<p><strong>Example:</strong></p>
<pre><code>var x = 10;
var y = 5;
if x &gt; y and not (y == 0) then print x / y else print 0</code></pre>
<h2 id="grammar-extensions-1">5. Grammar Extensions</h2>
<p>The grammar is extended to support control flow and booleans:</p>
<pre><code>?command: assign
        | print
        | vardecl
        | ifelse
        | while

assign: IDENTIFIER &quot;&lt;-&quot; expr
print: &quot;print&quot; expr
vardecl: &quot;var&quot; IDENTIFIER &quot;=&quot; expr
ifelse: &quot;if&quot; expr &quot;then&quot; CommandSequence &quot;else&quot; CommandSequence
while: &quot;while&quot; expr &quot;do&quot; CommandSequence

?expr: ...</code></pre>
<h2 id="abstract-syntax-tree-ast-extensions">6. Abstract Syntax Tree
(AST) Extensions</h2>
<p>The AST is extended to represent the new constructs:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> IfElse:</span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    cond: Expression</span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>    then_branch: CommandSequence</span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>    else_branch: CommandSequence</span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> While:</span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a>    cond: Expression</span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a>    body: CommandSequence</span></code></pre></div>
<p>Command sequences allow multiple commands in each branch or loop
body.</p>
<h2 id="ast-and-semantics-of-operators">6.1 AST and Semantics of
Operators</h2>
<h3 id="ast-node-for-operators">AST Node for Operators</h3>
<p>Operators in the language are represented in the AST using the
<code>Apply</code> node:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Apply:</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>    op: <span class="bu">str</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>    args: <span class="bu">list</span>[Expression]</span></code></pre></div>
<ul>
<li><code>op</code> is the operator name (e.g., ‘+’, ‘and’, ‘==’).</li>
<li><code>args</code> is a list of argument expressions (one for unary,
two for binary operators).</li>
</ul>
<h3 id="operator-class">Operator Class</h3>
<p>All operators are stored in the environment as <code>Operator</code>
objects:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Operator:</span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>    arity: <span class="bu">int</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>    fn: Callable[[<span class="bu">list</span>[EVal]], EVal]</span></code></pre></div>
<ul>
<li><code>arity</code> is the number of arguments the operator
expects.</li>
<li><code>fn</code> is the function implementing the operator’s
semantics.</li>
</ul>
<h3 id="semantics-of-operator-application">Semantics of Operator
Application</h3>
<p>Operator application is handled in the expression evaluator as
follows:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_expr(expr: Expression, env: Environment, state: State) <span class="op">-&gt;</span> EVal:</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> expr:</span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ...</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Apply(op, args):</span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a>            arg_vals <span class="op">=</span> [evaluate_expr(a, env, state) <span class="cf">for</span> a <span class="kw">in</span> args]</span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>            op_val <span class="op">=</span> lookup(env, op)</span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">isinstance</span>(op_val, Operator):</span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> op_val.arity <span class="op">!=</span> <span class="bu">len</span>(arg_vals):</span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">raise</span> <span class="pp">ValueError</span>(</span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true" tabindex="-1"></a>                        <span class="ss">f&quot;Operator &#39;</span><span class="sc">{</span>op<span class="sc">}</span><span class="ss">&#39; expects </span><span class="sc">{</span>op_val<span class="sc">.</span>arity<span class="sc">}</span><span class="ss"> arguments, got </span><span class="sc">{</span><span class="bu">len</span>(arg_vals)<span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true" tabindex="-1"></a>                    )</span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> op_val.fn(arg_vals)</span>
<span id="cb136-13"><a href="#cb136-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;</span><span class="sc">{</span>op<span class="sc">}</span><span class="ss"> is not an operator&quot;</span>)</span></code></pre></div>
<ul>
<li>The evaluator checks that the operator exists and that the number of
arguments matches its arity.</li>
<li>If the check passes, the operator’s function is applied to the
evaluated arguments.</li>
<li>If the check fails, a runtime error is raised.</li>
</ul>
<h3 id="example-operator-application">Example: Operator Application</h3>
<div class="sourceCode" id="cb137"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: evaluating x + y</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>Apply(op<span class="op">=</span><span class="st">&#39;+&#39;</span>, args<span class="op">=</span>[Var(<span class="st">&#39;x&#39;</span>), Var(<span class="st">&#39;y&#39;</span>)])</span></code></pre></div>
<p>This node will look up the ‘+’ operator in the environment, evaluate
<code>x</code> and <code>y</code>, check arity, and then apply the
addition function to the results.</p>
<h3 id="runtime-type-and-arity-checks">Runtime Type and Arity
Checks</h3>
<p>Operator application is checked at runtime for correct arity and
types, ensuring safe execution and clear error messages. For example,
applying <code>and</code> to non-booleans or dividing by zero will raise
an error.</p>
<h2 id="examples-of-control-flow-in-action">7. Examples of Control Flow
in Action</h2>
<h3 id="example-1-if-then-else">Example 1: If-Then-Else</h3>
<pre><code>var x = 1;
if x == 1 then print 42 else print 0</code></pre>
<p><strong>Output:</strong></p>
<pre><code>42</code></pre>
<h3 id="example-2-while-loop">Example 2: While Loop</h3>
<pre><code>var n = 3;
while n &gt; 0 do print n; n &lt;- n - 1</code></pre>
<p><strong>Output:</strong></p>
<pre><code>3
2
1</code></pre>
<h3 id="example-3-euclids-algorithm-gcd-using-subtraction">Example 3:
Euclid’s Algorithm (GCD) Using Subtraction</h3>
<pre><code>var a = 48; var b = 18;
while b != 0 do
    if a &gt; b then a &lt;- a - b else b &lt;- b - a;
print a</code></pre>
<p><strong>Output:</strong></p>
<pre><code>6</code></pre>
<h2 id="comparison-with-previous-chapters">8. Comparison with Previous
Chapters</h2>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr>
<th>Chapter 6: State</th>
<th>Chapter 7: Control Flow</th>
</tr>
</thead>
<tbody>
<tr>
<td>State and variable assignment</td>
<td>Adds conditionals and loops</td>
</tr>
<tr>
<td>No control flow</td>
<td>Programs can branch and repeat</td>
</tr>
<tr>
<td>Variables global to block</td>
<td>Block-local variable scoping</td>
</tr>
<tr>
<td>Only arithmetic expressions</td>
<td>Boolean and relational expressions</td>
</tr>
<tr>
<td>Arithmetic expressions only</td>
<td>Arithmetic, boolean, and relational expressions</td>
</tr>
</tbody>
</table>
<h2 id="conclusion-and-next-steps">9. Conclusion and Next Steps</h2>
<p>With the addition of control flow, our mini-language can now express
a wide range of algorithms and computations. Block-local variables and
unified operators bring us closer to the features of real-world
programming languages.</p>
<p>In the next chapter, we will explore more advanced features, such as
functions and closures, and discuss the semantic challenges they
introduce.</p>
<h2 id="exercises-2">10. Exercises</h2>
<ol type="1">
<li><strong>Write a program that prints the first 5 even numbers using a
while loop.</strong></li>
<li><strong>Modify the language to support nested if-then-else
statements.</strong></li>
<li><strong>Experiment with block-local variables: what happens if you
declare a variable inside an if or while block?</strong></li>
<li><strong>Implement a program that computes the factorial of a number
using a while loop.</strong></li>
</ol>
<h2 id="appendix-closures-denotable-values-and-state">Appendix:
Closures, Denotable Values, and State</h2>
<p>Closures (functions together with their captured environment) are a
prime example of a value that can be <strong>denoted</strong> (named and
referenced in the environment), but not <strong>expressed</strong>
(evaluated to a simple value) or <strong>memorized</strong> (stored in
the state), unless special provisions are made.</p>
<h3 id="why-closures-are-special">Why Closures Are Special</h3>
<ul>
<li>In a language with lexical scoping, a closure “remembers” the
environment in which it was created, including variables that may have
gone out of scope.</li>
<li>If closures are allowed to be stored in state (e.g., assigned to
variables), the variables they capture can outlive their lexical scope,
breaking the clean separation between environment (static, lexical) and
state (dynamic, mutable).</li>
<li>This can lead to subtle bugs and makes reasoning about programs more
complex.</li>
</ul>
<h3 id="special-provisions-for-closures">Special Provisions for
Closures</h3>
<p>To allow closures to be stored in state safely, languages typically
provide:</p>
<ul>
<li><strong>Heap allocation for environments:</strong> Captured
variables are stored on the heap, so they persist as long as the closure
does, not just for the duration of the block.</li>
<li><strong>Garbage collection or reference counting:</strong> To
reclaim memory when closures and their environments are no longer
accessible.</li>
<li><strong>First-class environments:</strong> Environments are
represented as first-class values that can be stored, passed, and
manipulated at runtime.</li>
</ul>
<h4 id="example-javascript">Example (JavaScript):</h4>
<div class="sourceCode" id="cb144"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">makeCounter</span>() {</span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">function</span> () {</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">++</span>x<span class="op">;</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>  }<span class="op">;</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> counter <span class="op">=</span> <span class="fu">makeCounter</span>()<span class="op">;</span></span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="fu">counter</span>())<span class="op">;</span> <span class="co">// 1</span></span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="fu">counter</span>())<span class="op">;</span> <span class="co">// 2</span></span></code></pre></div>
<p>Here, <code>x</code> lives as long as the closure does, even after
<code>makeCounter</code> has returned.</p>
<h3 id="in-our-mini-language">In Our Mini-Language</h3>
<p>In the current chapter, only simple values (like numbers and
booleans) are allowed to be stored in state. Closures are not yet
supported as storable values, which keeps the semantics simple and
reasoning about programs tractable. Supporting closures as storable
values requires the special provisions described above.</p>
<h2 id="example-the-danger-of-memorizing-closures">Example: The Danger
of Memorizing Closures</h2>
<p>Suppose our mini-language supported lambda-abstractions (anonymous
functions) and allowed them to capture local variables. Consider the
following (hypothetical) example:</p>
<pre class="minilang"><code>var x = 0;
if cond then
    var y = 42;
    x &lt;- lambda() { return y }  // y is a local variable, now accessible outside of its scope!
else
    // do something else

print x() // call the closure to read y outside of its scope</code></pre>
<p>Here, the lambda-abstraction <code>lambda() { return y }</code>
captures the local variable <code>y</code> declared inside the
<code>then</code> branch. We then assign this closure to the global
variable <code>x</code>.</p>
<p>If the language allows closures to be stored in state (e.g., as
variable values), the closure may outlive the scope of <code>y</code>.
Later, calling <code>x()</code> would attempt to access <code>y</code>,
which no longer exists—leading to undefined behavior or runtime
errors.</p>
<p>This illustrates why special care is needed when allowing closures to
be stored in state: the captured environment must persist as long as the
closure does, or else memory safety and correctness are compromised.</p>
</body>
</html>
